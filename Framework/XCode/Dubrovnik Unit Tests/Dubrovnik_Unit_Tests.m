//
//  Dubrovnik_Unit_Tests.m
//  Dubrovnik Unit Tests
//
//  Created by Jonathan on 02/07/2013.
//
//
#import <Dubrovnik/Dubrovnik.h>
#import "Dubrovnik_Unit_Tests.h"
#import "DBUReferenceObject.h"
#import "DBUIReferenceObject.h"
#import "DBUGenericReferenceObjectA2.h"
#import <Mono.mscorlib/Framework.h>

static BOOL m_runningAutoGenCodeTest = NO;

// toggle 0-1
// it may be useful to disable certain tests when adding support for new features

/*

 two sets of unit test data exist.
 one is hand coded, the other generated by the code gen.

 when DB_RUN_MANUAL_CODE_TEST evaluates to 0 the tests
 are not run against the manually generated unit test model.

 when DB_RUN_AUTO_GENERATED_CODE_TEST evaluates to 0 the tests
 are not run against the generated unit test model.
 
 */
#define DB_RUN_MANUAL_CODE_TEST 1
#define DB_RUN_AUTO_GENERATED_CODE_TEST 1

#define DB_VALUETYPE_BY_REFERENCE_SUPPORT 1

#if DB_RUN_AUTO_GENERATED_CODE_TEST == 1
#import "Dubrovnik_UnitTests.h"
#endif


#define RESET_EVENT_VARS(X)    self.event1Fired = X; \
self.event2Fired = X; \
testObject.event1Fired = X; \
testObject.event2Fired = X; \
eventTarget.event1Fired = X; \
eventTarget.event2Fired = X; \
eventTarget1.event1Fired = X; \
eventTarget1.event2Fired = X

@implementation NSObject (Dubrovnik_UnitTests)
- (BOOL)dbTestString:(NSString *)string
{
    return (string && [string isKindOfClass:[NSString class]] && [(id)self rangeOfString:string].location != NSNotFound) ? YES : NO;
}
@end

NSString *DBUTestString = @"Dubrovnik";

// test failure notices
#define DBUObjectNotCreated @"Object not created"
#define DBUObjectIsNil @"Object is nil"
#define DBUBooleanTestFailed @"Boolean test failed"
#define DBUEqualityTestFailed @"Equality test failed"
#define DBUInequalityTestFailed @"Inequality test failed"
#define DBULessThanTestFailed @"Less than test failed"
#define DBUGreaterThanTestFailed @"Greater than test failed"
#define DBUSubstringTestFailed @"Substring not found"
#define DBUCountTestFailed @"Count test failed"
#define DBUNotNilTestFailed @"Not nil test failed"
#define DBUExceptionTestFailed @"An exception test failed"
#define DBUObjectNotFound @"Object not found"
#define DBUNilTestFailed @"Nil test failed"
#define DBUClassEqualityTestFailed @"Class equality test failed"
#define DBUDesignedToFailTestPassed @"Designed to fail test passed"
#define DBUPointerEqualityTestFailed @"Pointer equality test failed"
#define DBUPointerInequalityTestFailed @"Pointer inequality test failed"

static BOOL _setup = NO;
static MonoAssembly *monoAssembly;

@interface EventTarget : NSObject <EventTarget>
@property NSUInteger event1Fired;
@property NSUInteger event2Fired;

@end

@interface Dubrovnik_Unit_Tests()

- (void)doTestReferenceClass:(Class)testClass iterations:(int)iterations;
- (id)doTestConstructorsWithclass:(Class)testClass;
- (void)doTestFields:(id)refObject class:(Class)testClass;
- (void)doTestExtensionMethods:(id)refObject class:(Class)testClass;
- (void)doTestMethods:(id)refObject class:(Class)testClass;
- (void)doTestProperties:(id)refObject class:(Class)testClass;
- (void)doTestStructRepresentation:(id)refObject class:(Class)testClass;
- (void)doTestObjectRepresentation:(id)refObject class:(Class)testClass;
- (void)doTestArrayProperties:(id)refObject class:(Class)testClass;
- (void)doTestArrayListRepresentation:(id)refObject class:(Class)testClass;
- (void)doTestArrayMethods:(id)refObject class:(Class)testClass;
- (void)doTestPointerProperties:(id)refObject class:(Class)testClass;
- (void)doTestPointerMethods:(id)refObject class:(Class)testClass;
@end

#warning NSData implementation is not tested

@implementation Dubrovnik_Unit_Tests

#pragma mark -
#pragma mark Test lifecycle

- (void)setUp
{
    if (_setup) return;
    
    _setup = YES;
    _verbose = YES;
    
    [super setUp];
    
    // the unit test assembly exe is in the OCUnit test bundle resource folder.
    // if it is missing then make sure to build the dotNet unit test solution.
    // TODO: automate .NET component build
    NSString *assemblyName = @"Dubrovnik.UnitTests";
    NSString *assemblyFile = [[NSBundle bundleForClass:[self class]] pathForResource:assemblyName ofType:@"exe"];
    
    // validate the assembly
    if (![[NSFileManager defaultManager] fileExistsAtPath:assemblyFile]) {
        XCTAssertTrue(NO, @"Managed test assembly not found. Did you build it?");
        abort();
    }
    
    // use the default mono environment
    DBManagedEnvironment *monoEnv = [DBManagedEnvironment defaultEnvironment];

    // the environment delegate must be able to load assemblies on demand
    [monoEnv setDelegate:self];
         
    // open the assembly 
    monoAssembly = [monoEnv openAssembly:assemblyName path:assemblyFile];
    XCTAssertTrue(monoAssembly, @"Cannot open assembly : %@", assemblyFile);
    
    // Note:
    // MonoReflectionType represents System.Type
    // MonoReflectionAssembly represents System.Reflection.Assembly
    MonoReflectionAssembly *monoReflectionAssembly = mono_assembly_get_object(mono_domain_get(), monoAssembly);
    
    // get the version via reflection
    System_Reflection_Assembly *managedAssembly = [[System_Reflection_Assembly alloc] initWithMonoObject:(MonoObject *)monoReflectionAssembly];
    NSString *assemblyVersion = managedAssembly.getName.version.toString;
    
    XCTAssertTrue(assemblyVersion, @"Assembly version not found");
    
    // initialise the time zone
    [NSTimeZone setDefaultTimeZone:[NSTimeZone timeZoneWithName:@"UTC"]];
    
    // initialise managed date time conversion options.
    [NSDate setMonoDateTimeOptions: (DBMonoDateTimeOptionAssertOnUTCViolation |
                                     DBMonoDateTimeOptionLogWarnings)];
    
    // invoke the assembly static main.
    // this prepares the application domain and validates that the assembly is loaded and functional.
    // the assembly will remain loaded and accessible once the assmbly invocation completes.
    // this operation should only be performed once on any given managed environment.
    int argc = 1;
    char *argv[] = {(char *)assemblyFile.UTF8String};
    int retval = [monoEnv invokeAssembly:monoAssembly prepareThreading:NO argCount:argc arguments:argv];
    XCTAssertTrue(retval == 0, @"Call to assembly entry point failed");
    
    [self doSetupTests];
}

- (void)tearDown
{
    // Terminate the environment
    [[DBManagedEnvironment currentEnvironment] terminate];
    
    [super tearDown];
}


- (void)doSetupTests
{
    DUReferenceObject_ *refObj2 = nil;
    
    // these tests are sensitive to the state of the caches so we run them now
    // before the other tests dirty them.
    // the release pools should ensure that the caches if not pristine will be clear of object references
    @autoreleasepool {
        Dubrovnik_UnitTests_IReferenceObject1 *iRefObj = nil;
        @autoreleasepool {
            // allocate a primary instance
            DUReferenceObject_ *refObj = [DUReferenceObject_ new];
            
            // allocate a secondary instance
            iRefObj = DB_INTERFACE(Dubrovnik_UnitTests_IReferenceObject1, refObj);
            
            // validate primary and secondary status
            XCTAssertTrue(refObj.isPrimaryInstance, DBUBooleanTestFailed);
            XCTAssertTrue(!iRefObj.isPrimaryInstance, DBUBooleanTestFailed);
        }
        
        // when the primary instance deallocates the secondary instance should get upgraded to primary status
        XCTAssertTrue(iRefObj.isPrimaryInstance, DBUBooleanTestFailed);
        
        // if we create a new non interface instance it should not be primary
        refObj2 = [[DUReferenceObject_ alloc] initWithMonoObject:iRefObj.monoObject];
        XCTAssertTrue(!refObj2.isPrimaryInstance, DBUBooleanTestFailed);
    }
    
    // we should see another primary instance upgrade here
    XCTAssertTrue(refObj2.isPrimaryInstance, DBUBooleanTestFailed);
}

#pragma mark -
#pragma mark Top level tests

- (void)testDateRepresentation
{
    NSDate *dateNow = [NSDate date];
    MonoObject *monoDateTime = [dateNow monoDateTime];
    NSDate *dateFromMonoObject = [NSDate dateWithMonoDateTime:monoDateTime];
    
    // validate the NSDate representation
    XCTAssertTrue(fabs([dateFromMonoObject timeIntervalSinceDate:dateNow]) < 0.1, @"bad date");  // sanity check
    
    // validate the Mono representatiom
    int64_t ticks = DB_UNBOX_INT64(DBMonoObjectGetProperty(monoDateTime, "Ticks"));
    MonoString *monoString = mono_object_to_string_ex(monoDateTime, NULL);
    NSString *dateString = [NSString stringWithMonoString:monoString];
    NSLog(@"NSDate date = %@ Mono DateTime = %@ ticks = %lld", dateNow, dateString, ticks);
}

- (void)testNumberRepresentation
{
    // test
    DBNumber *n1 = [@((int)1) dbNumberFromIntValue];

    XCTAssertTrue(*(int *)[n1 valuePointer] == 1, DBUEqualityTestFailed);
    XCTAssertTrue([n1 valuePointer] == [n1 valuePointer], DBUEqualityTestFailed);
    XCTAssertTrue(*(int *)[n1 valuePointer] == *(int *)[n1 valuePointer], DBUEqualityTestFailed);
    
    // basic equality
    DBNumber *n2 = [DBNumber numberWithInt:1];
    XCTAssertTrue(*(int *)[n2 valuePointer] == 1, DBUEqualityTestFailed);
    XCTAssertTrue(*(int *)[n2 valuePointer] == *(int *)[n1 valuePointer], DBUEqualityTestFailed);
    
    // create int from MonoObject
    int intValue = 10289;
    DBNumber *nInt = [[DBTypeManager sharedManager] objectWithMonoObject:DB_BOX_INT32(intValue)];
    XCTAssertTrue(strcmp([nInt objCType], @encode(int)) == 0, DBUEqualityTestFailed);
    XCTAssertTrue(*(int *)[nInt valuePointer] == intValue, DBUEqualityTestFailed);
    
    // create long long from MonoObject
    long long longLongValue = LONG_LONG_MAX;
    DBNumber *nLongLong = [NSNumber objectWithMonoObject:DB_BOX_INT64(longLongValue)];
    XCTAssertTrue(strcmp([nLongLong objCType], @encode(long long)) == 0, DBUEqualityTestFailed);
    XCTAssertTrue(*(long long *)[nLongLong valuePointer] == longLongValue, DBUEqualityTestFailed);

    // create double from MonoObject
    double doubleValue = 13245456.;
    DBNumber *nDouble = [NSNumber numberWithMonoObject:DB_BOX_DOUBLE(doubleValue)];
    XCTAssertTrue(strcmp([nDouble objCType], @encode(double)) == 0, DBUEqualityTestFailed);
    XCTAssertTrue(*(double *)[nDouble valuePointer] == doubleValue, DBUEqualityTestFailed);
    
    // test DBNumber
    DBNumber *dn = [[DBNumber alloc] initWithInt:100];
    DBNumber *dn1 = [DBNumber numberWithInt:100];
    XCTAssertTrue([[dn stringValue] isEqualToString:@"100"], DBUEqualityTestFailed);
    
    // test NSNumber methods
    XCTAssertTrue([dn compare:@((int)100)] == NSOrderedSame, DBUEqualityTestFailed);
    XCTAssertTrue([dn compare:@((float)100)] == NSOrderedSame, DBUEqualityTestFailed);
    XCTAssertTrue([dn isEqualToNumber:dn1], DBUEqualityTestFailed);
    XCTAssertTrue([dn isEqualToNumber:@((int)100)], DBUEqualityTestFailed);
    XCTAssertNotNil([dn descriptionWithLocale:nil], DBUNotNilTestFailed);
    
    // test encoding
    XCTAssertTrue([@([[DBNumber numberWithBool:YES] monoObjCType]) isEqualToString:@(@encode(BOOL))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithChar:1] monoObjCType]) isEqualToString:@(@encode(char))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithUnsignedChar:1] monoObjCType]) isEqualToString:@(@encode(unsigned char))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithShort:1] monoObjCType]) isEqualToString:@(@encode(short))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithUnsignedShort:1] monoObjCType]) isEqualToString:@(@encode(unsigned short))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithInt:1] monoObjCType]) isEqualToString:@(@encode(int))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithUnsignedInt:1] monoObjCType]) isEqualToString:@(@encode(unsigned int))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithLong:1] monoObjCType]) isEqualToString:@(@encode(long))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithUnsignedLong:1] monoObjCType]) isEqualToString:@(@encode(unsigned long))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithLongLong:1] monoObjCType]) isEqualToString:@(@encode(long long))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithUnsignedLongLong:1] monoObjCType]) isEqualToString:@(@encode(unsigned long long))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithFloat:1] monoObjCType]) isEqualToString:@(@encode(float))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithDouble:1] monoObjCType]) isEqualToString:@(@encode(double))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithInteger:1] monoObjCType]) isEqualToString:@(@encode(NSInteger))], DBUEqualityTestFailed);
    XCTAssertTrue([@([[DBNumber numberWithUnsignedInteger:1] monoObjCType]) isEqualToString:@(@encode(NSUInteger))], DBUEqualityTestFailed);
    XCTAssertFalse([@([[DBNumber numberWithUnsignedInteger:1] monoObjCType]) isEqualToString:@(@encode(char))], DBUDesignedToFailTestPassed);
    
    // test setCompareEnforcesTypeMatch
    DBNumber *typeMatchIntN = [@55 dbNumberFromIntValue];
    DBNumber *typeMatchLongN = [@55 dbNumberFromLongValue];
    DBNumber *typeMatchFloatN = [@55 dbNumberFromFloatValue];
    
    DBNumber *typeMatchDoubleN = [@55 dbNumberFromDoubleValue];
    
    // test default behaviour with NSNumber
    XCTAssertTrue([typeMatchIntN isEqual:@55.], DBUEqualityTestFailed);
    XCTAssertTrue([typeMatchLongN isEqual:@55.], DBUEqualityTestFailed);
    XCTAssertTrue([typeMatchFloatN isEqual:@55.], DBUEqualityTestFailed);

    // test default behaviour with DBNumber
    XCTAssertTrue([typeMatchIntN isEqual:typeMatchDoubleN], DBUEqualityTestFailed);
    XCTAssertTrue([typeMatchLongN isEqual:typeMatchDoubleN], DBUEqualityTestFailed);
    XCTAssertTrue([typeMatchFloatN isEqual:typeMatchDoubleN], DBUEqualityTestFailed);
    
    // enforce comparison type match
    [typeMatchIntN setCompareEnforcesTypeMatch];
    [typeMatchLongN setCompareEnforcesTypeMatch];
    [typeMatchFloatN setCompareEnforcesTypeMatch];
    
    // NSumber behaviour should remain unchanged
    XCTAssertTrue([typeMatchIntN isEqual:@55.], DBUEqualityTestFailed);
    XCTAssertTrue([typeMatchLongN isEqual:@55.], DBUEqualityTestFailed);
    XCTAssertTrue([typeMatchFloatN isEqual:@55.], DBUEqualityTestFailed);
    
    // DBNumber should fail to match instance initialised with another type
    XCTAssertFalse([typeMatchIntN isEqual:typeMatchDoubleN], DBUInequalityTestFailed);
    XCTAssertFalse([typeMatchLongN isEqual:typeMatchDoubleN], DBUInequalityTestFailed);
    XCTAssertFalse([typeMatchFloatN isEqual:typeMatchDoubleN], DBUInequalityTestFailed);
    
    // DBNumber should match instance initialised with matching type
    XCTAssertTrue([typeMatchIntN isEqual:[@55 dbNumberFromIntValue]], DBUEqualityTestFailed);
    XCTAssertTrue([typeMatchLongN isEqual:[@55 dbNumberFromLongValue]], DBUEqualityTestFailed);
    XCTAssertTrue([typeMatchFloatN isEqual:[@55 dbNumberFromFloatValue]], DBUEqualityTestFailed);
    
}

- (void)testStringRepresentation
{
    NSString *string1 = @"I am the test string";
    DBString *string2 = [DBString objectWithMonoObject:[string1 monoString]];
    XCTAssertTrue([string1 isEqualToString:string2], DBUEqualityTestFailed);
    
    // create string from mono object
    NSString *string3 = [[DBTypeManager sharedManager] objectWithMonoObject:[string2 representedMonoObject]];
    XCTAssertTrue([string1 isEqualToString:string3], DBUEqualityTestFailed);
}

- (void)testReferenceClass
{
    
#if DB_RUN_MANUAL_CODE_TEST == 1
    
    m_runningAutoGenCodeTest = NO;
    
    // When adding support for new features it is best to
    // ensure that the manually coded reference class passes its tests first.
    // DB_RUN_AUTO_GENERATED_CODE_TEST can be #defined as 0
    //
    // Once the manually code class performs as required it can be used
    // as a guide for implementing the auto generated code
    
    NSLog(@"==============================================");
    NSLog(@"Testing manually generated reference object");
    NSLog(@"==============================================");

    @autoreleasepool {
        
        // test reference class
        [self doTestReferenceClass:[DBUReferenceObject class] iterations:3];
        
        // managed object allocation
        id managedObject = [[DBUReferenceObject alloc] init];
        (void)managedObject;
        
        // unmanaged object allocation
        NSString *unmanagedObject = [NSString stringWithFormat:@"%@", @"TEST"];
        (void)unmanagedObject;
        
    }
    
#endif
    
#if DB_RUN_AUTO_GENERATED_CODE_TEST == 1
    
    m_runningAutoGenCodeTest = YES;
    
    NSLog(@"==============================================");
    NSLog(@"Testing auto generated reference object");
    NSLog(@"==============================================");

    @autoreleasepool {
        [self doTestReferenceClass:[DUReferenceObject_ class] iterations:3];
    }

    //
    // test enumerations
    //
    XCTAssertTrue(Dubrovnik_UnitTests_IntEnum_val1 == [DUIntEnum_ val1], DBUEqualityTestFailed);
    XCTAssertTrue(Dubrovnik_UnitTests_IntEnum_val2 == [DUIntEnum_ val2], DBUEqualityTestFailed);
    XCTAssertTrue(Dubrovnik_UnitTests_IntEnum_val3 == [DUIntEnum_ val3], DBUEqualityTestFailed);
    XCTAssertTrue(Dubrovnik_UnitTests_IntEnum_val4 == [DUIntEnum_ val4], DBUEqualityTestFailed);

    XCTAssertTrue(Dubrovnik_UnitTests_LongEnum_val1 == [DULongEnum_ val1], DBUEqualityTestFailed);
    XCTAssertTrue(Dubrovnik_UnitTests_LongEnum_val2 == [DULongEnum_ val2], DBUEqualityTestFailed);
    XCTAssertTrue(Dubrovnik_UnitTests_LongEnum_val3 == [DULongEnum_ val3], DBUEqualityTestFailed);
    XCTAssertTrue(Dubrovnik_UnitTests_LongEnum_val4 == [DULongEnum_ val4], DBUEqualityTestFailed);
    
#endif
    
   
}

- (void)testInstanceCache
{
    // load tests
    // for details of SGEN memory usage see http://www.mono-project.com/docs/advanced/garbage-collector/sgen/working-with-sgen/
    /*
     
     The instance cache should fill up as objects are allocated and then discard them automatically when the objects are deallocated
     as the enclosing autorelease pool drains.
     
     */
    NSInteger loopCount = 0;
    NSInteger loopMax = 10;
    NSUInteger allocationCount = 0;
    NSUInteger cacheCount = [DBPrimaryInstanceCache sharedCache].count;
    NSArray *loadSizes = @[@(10), @(22), @(55), @(100), @(189), @(213), @(334), @(478), @(505), @(1003), @(2002), @(3000), @(4001), @(5005), @(6000), @(7234)];

    do {
        // when the pool is drained all managed instances allocated in this autorelease block should have been released.
        @autoreleasepool {
            
            NSUInteger itemCount = 100;
            NSMutableArray *itemArray  = [NSMutableArray arrayWithCapacity:itemCount];
            
            NSLog(@"Memory load test %lu of %lu...", loopCount, loopMax);
            
            // allocate objects
            for (NSUInteger i = 0; i < itemCount; i++) {
                
                // objects < 8000b are allocated to the nursery under SGEN.
                NSData *loadData = nil;
                DBManagedObject *managedObject = nil;
                for (NSNumber *loadSize in loadSizes) {
                    loadData = [self createNSData:loadSize.integerValue];
                    managedObject = [DBManagedObject objectWithMonoObject:(MonoObject *)[loadData monoArray]];
                    [itemArray addObject:managedObject];
                    allocationCount++;
                }
                
                // larger objects are allocated to the separate large object space
                for (NSNumber *loadSize in loadSizes) {
                    loadData = [self createNSData:20*loadSize.integerValue];
                    managedObject = [DBManagedObject objectWithMonoObject:(MonoObject *)[loadData monoArray]];
                    [itemArray addObject:managedObject];
                    allocationCount++;
                }
            }
            
            [itemArray removeAllObjects];
        }
    } while (++loopCount < loopMax);
    
    // number of cache objects should be preserved
    NSUInteger finalCacheCount = [DBPrimaryInstanceCache sharedCache].count;
    XCTAssertTrue(cacheCount == finalCacheCount, DBUEqualityTestFailed);
    
    NSLog(@"Total : %lu allocations", allocationCount);
    NSLog(@"Initial cache count : %lu", cacheCount);
    NSLog(@"Final cache count : %lu", finalCacheCount);
    
    // a test compaction
    [[DBPrimaryInstanceCache sharedCache] compact];
    
    // log the cache
    [[DBPrimaryInstanceCache sharedCache] logPrimaryInstanceCache:DBLogPrimaryInstanceCacheAll];
}

- (void)testMultiStringGeneration
{
    MonoObject *monoObject = [@"test" monoObject];
    
    for (NSUInteger i = 0; i < 1e5; i++) {
        id object = [[DBTypeManager sharedManager] objectWithMonoObject:monoObject];
        (void)object;
    }
}

#pragma mark -
#pragma mark Helper methods

- (NSData *)createNSData:(NSUInteger)dataSize
{
    NSMutableData *theData = [NSMutableData dataWithCapacity:dataSize];
    for (unsigned int i = 0 ; i < dataSize/8 ; ++i )
    {
        u_int64_t bits = 256;
        [theData appendBytes:(void*)&bits length:8];
    }
    return theData;
}

// mono_object_to_string is buggy
// https://github.com/mono/mono/pull/708/files
MonoString *
mono_object_to_string_ex (MonoObject *obj, MonoObject **exc)
{
    static MonoMethod *to_string = NULL;
    MonoMethod *method;
    void *target = obj;
    
    //g_assert (obj);
    
    if (!to_string)
        to_string = mono_class_get_method_from_name_flags (mono_get_object_class (), "ToString", 0, 0x0040 | 0x0006);
    
    method = mono_object_get_virtual_method (obj, to_string);
    
    // Unbox value type if needed
    if (mono_class_is_valuetype (mono_method_get_class (method))) {
        target = mono_object_unbox (obj);
    }
    
    return (MonoString *) mono_runtime_invoke (method, target, NULL, exc);
}


#pragma mark -
#pragma mark Subcomponent tests

- (id)doTestConstructorsWithclass:(Class)testClass
{
    
    //
    // default constructor
    //
    id refObject = [testClass new];
    
    XCTAssertNotNil(refObject, DBUObjectNotCreated);
    
    // log the class
    if (0) {
        [refObject logMonoClassInfo];
    }
    
    //
    // constructor overloads
    //
    NSString *ctorString = @"Constructor with one string argument";
    refObject = [testClass new_withValue:(id)ctorString];
    XCTAssertNotNil(refObject, DBUObjectNotCreated);
    XCTAssertTrue([[refObject stringProperty] isEqualToString:ctorString], DBUEqualityTestFailed);
    
    NSString *ctorString1 = @"Constructor with two ";
    NSString *ctorString2 = @"string arguments";
    refObject = [testClass new_withValue1:ctorString1 value2:ctorString2];
    XCTAssertNotNil(refObject, DBUObjectNotCreated);
    XCTAssertTrue([[refObject stringProperty] isEqualToString:[ctorString1 stringByAppendingString:ctorString2]], DBUEqualityTestFailed);
    
    return refObject;
}

- (void)doTestGenericConstructors:(Class)testClass
{
    // allocate core generic types from class
    System_Collections_Generic_ListA1 *listA1 = [System_Collections_Generic_ListA1 newWithTypeParameters:@[[System_Object class]]];
    System_Collections_Generic_DictionaryA2 *dictionaryA2 = [System_Collections_Generic_DictionaryA2 newWithTypeParameters:@[[System_String class], [System_Object class]]];
    System_Collections_Generic_KeyValuePairA2 *keyValuePairA2 = [System_Collections_Generic_KeyValuePairA2 newWithTypeParameters:@[[System_String class], [System_Object class]]];
    
    // allocate core generic types from type name
    System_Collections_Generic_ListA1 *listA1_1 = (id)[System_Object newObjectWithGenericTypeDefinition:"System.Collections.Generic.List`1" typeParameters:@[[System_Object class]]];
    System_Collections_Generic_DictionaryA2 *dictionaryA2_1 = (id)[System_Object newObjectWithGenericTypeDefinition:"System.Collections.Generic.Dictionary`2" typeParameters:@[[System_String class], [System_Object class]]];
    System_Collections_Generic_KeyValuePairA2 *keyValuePairA2_1 = (id)[System_Object newObjectWithGenericTypeDefinition:"System.Collections.Generic.KeyValuePair`2" typeParameters:@[[System_String class], [System_Object class]]];
    
    // System_Object -description calls .ToString which returns a description including the generic parameter types, hence the string comparisons
    XCTAssertTrue([listA1.description isEqualToString:listA1_1.description], DBUEqualityTestFailed);
    XCTAssertTrue([dictionaryA2.description isEqualToString:dictionaryA2_1.description], DBUEqualityTestFailed);
    XCTAssertTrue([keyValuePairA2.description isEqualToString:keyValuePairA2_1.description], DBUEqualityTestFailed);
    
    //
    // Dictionary<TKey,TValue> tests
    //
    System_Object *numInt = DBNumInt(51).managedObject;
    System_Object *numLongLong = DBNumLongLong(510).managedObject;
    System_Object *numFloat = DBNumFloat(5100).managedObject;
    System_Object *numDouble = DBNumFloat(51000).managedObject;
    
    // populate dictionary
    [dictionaryA2 addKey:[@"name" managedObject] value:[@"bob" managedObject]];
    [dictionaryA2 addKey:[@"address" managedObject] value:[@"over here" managedObject]];
    [dictionaryA2 addKey:[@"int" managedObject] value:numInt];
    [dictionaryA2 addKey:[@"longLong" managedObject] value:numLongLong];
    [dictionaryA2 addKey:[@"float" managedObject] value:numFloat];
    [dictionaryA2 addKey:[@"double" managedObject] value:numDouble];
    
    XCTAssertTrue([[dictionaryA2 objectForKey:@"name"] isEqualToString:@"bob"], DBUEqualityTestFailed);
    XCTAssertTrue([[dictionaryA2 objectForKey:@"address"] isEqualToString:@"over here"], DBUEqualityTestFailed);
    XCTAssertTrue([[dictionaryA2 objectForKey:@"int"] isEqual:DBNumInt(51)], DBUEqualityTestFailed);
    XCTAssertTrue([[dictionaryA2 objectForKey:@"longLong"] isEqual:DBNumLongLong(510)], DBUEqualityTestFailed);
    XCTAssertTrue([[dictionaryA2 objectForKey:@"float"] floatValue] == 5100, DBUEqualityTestFailed);
    XCTAssertTrue([[dictionaryA2 objectForKey:@"double"] doubleValue] == 51000, DBUEqualityTestFailed);
    
    // convert to NSDictionary
    NSDictionary <NSString *, NSObject *> *dictionary = [dictionaryA2 dictionary];
    XCTAssertTrue([(NSString *)dictionary[@"name"] isEqualToString:@"bob"], DBUEqualityTestFailed);
    XCTAssertTrue([(NSString *)dictionary[@"address"] isEqualToString:@"over here"], DBUEqualityTestFailed);
    XCTAssertTrue([(NSNumber *)dictionary[@"int"] intValue] == 51, DBUEqualityTestFailed);
    XCTAssertTrue([(NSNumber *)dictionary[@"longLong"] intValue] == 510, DBUEqualityTestFailed);
    XCTAssertTrue([(NSNumber *)dictionary[@"float"] intValue] == 5100, DBUEqualityTestFailed);
    XCTAssertTrue([(NSNumber *)dictionary[@"double"] intValue] == 51000, DBUEqualityTestFailed);

    //
    // List<T> tests
    //
    [listA1 add:@"bob".managedObject];
    [listA1 add:@"over here".managedString];
    [listA1 add:numInt];
    
    // indexing with objectAtIndex:
    System_Collections_IList *iList = [listA1 list];
    XCTAssertTrue([[iList objectAtIndex:0] isEqualToString:@"bob"], DBUEqualityTestFailed);
    XCTAssertTrue([[iList objectAtIndex:1] isEqualToString:@"over here"], DBUEqualityTestFailed);
    XCTAssertTrue([[iList objectAtIndex:2] intValue] == 51, DBUEqualityTestFailed);
    XCTAssertTrue([iList int32AtIndex:2] == 51, DBUEqualityTestFailed);
    
    // indexing with managed indexer exposed as get_Item_withIndex:
    XCTAssertTrue([(NSString *)[iList get_Item_withIndex:0] isEqualToString:@"bob"], DBUEqualityTestFailed);
    XCTAssertTrue([(NSString *)[iList get_Item_withIndex:1] isEqualToString:@"over here"], DBUEqualityTestFailed);
    XCTAssertTrue([(NSNumber *)[iList get_Item_withIndex:2] intValue] == 51, DBUEqualityTestFailed);

    // convert to NSArray
    NSArray <NSString *> *list = [listA1 array];
    XCTAssertTrue([(NSString *)list[0] isEqualToString:@"bob"], DBUEqualityTestFailed);
    XCTAssertTrue([(NSString *)list[1] isEqualToString:@"over here"], DBUEqualityTestFailed);
    
    // allocate list<System.Char> and populate
    /* TODO
    Test fails
     
    8 bit type name encoding collisions at work here
    char bool byte
     
    System_Collections_Generic_ListA1 *charList = [System_Collections_Generic_ListA1 listWithObjects:@[DBNumChar(14), DBNumChar(89)]];
    [charList add:[DBNumChar(24) managedObject]];
    [charList add:[DBNumChar(67) managedObject]];
    STAssertTrue([[charList list] charAtIndex:2] == 24, DBUEqualityTestFailed);
    STAssertTrue([[charList list] charAtIndex:3] == 67, DBUEqualityTestFailed);
    STAssertTrue(charList.count == 4, DBUEqualityTestFailed);
     */
    
    // allocate list<System.Int16> and populate
    System_Collections_Generic_ListA1 *int16List = [System_Collections_Generic_ListA1 listWithObjects:@[DBNumShort(12), DBNumShort(45)]];
    [int16List add:[DBNumShort(63) managedObject]];
    [int16List add:[DBNumShort(84) managedObject]];
    System_Collections_IList *int16IList = [int16List list];
    XCTAssertTrue([int16IList int16AtIndex:2] == 63, DBUEqualityTestFailed);
    XCTAssertTrue([int16IList int16AtIndex:3] == 84, DBUEqualityTestFailed);
    XCTAssertTrue(int16List.count == 4, DBUEqualityTestFailed);
    
    // allocate list<System.Int32> and populate
    System_Collections_Generic_ListA1 *int32List = [System_Collections_Generic_ListA1 listWithObjects:@[DBNumInt(1), DBNumInt(2)]];
    [int32List add:[DBNumInt(3) managedObject]];
    [int32List add:[DBNumInt(4) managedObject]];
    XCTAssertTrue([[int32List list] int32AtIndex:2] == 3, DBUEqualityTestFailed);
    XCTAssertTrue([[int32List list] int32AtIndex:3] == 4, DBUEqualityTestFailed);
    XCTAssertTrue(int32List.count == 4, DBUEqualityTestFailed);
    
    // allocate list<System.Int64> and populate
    NSArray *int64Array = @[DBNumLongLong(10), DBNumLongLong(20)];
    System_Collections_Generic_ListA1 *int64List = [System_Collections_Generic_ListA1 listWithObjects:int64Array];
    [int64List add:[DBNumLongLong(30) managedObject]];
    [int64List add:[DBNumLongLong(40) managedObject]];
    XCTAssertTrue([[int64List list] int64AtIndex:2] == 30, DBUEqualityTestFailed);
    XCTAssertTrue([[int64List list] int64AtIndex:3] == 40, DBUEqualityTestFailed);
    XCTAssertTrue(int64List.count == 4, DBUEqualityTestFailed);
    
    // derive ListA1 from array with explicit generic type parameter class derived from object instance.
    // we can also use a [System_Object class] pointer but as yet we dont have a generated System_Int64 class
    int64List = [int64Array managedListA1WithTypeParameter:int64Array[0]];
    XCTAssertTrue([[int64List list] int64AtIndex:0] == 10, DBUEqualityTestFailed);
    XCTAssertTrue([[int64List list] int64AtIndex:1] == 20, DBUEqualityTestFailed);
    XCTAssertTrue(int64List.count == 2, DBUEqualityTestFailed);

    // derive ListA1 from array with explicit generic type parameter monoType
    MonoObject *monoObject = [int64Array[0] monoObject];
    MonoType *monoType = [DBType monoTypeForMonoObject:monoObject];
    NSValue *typeValue = [NSValue valueWithPointer:monoType];
    int64List = [int64Array managedListA1WithTypeParameter:typeValue];
    XCTAssertTrue([[int64List list] int64AtIndex:0] == 10, DBUEqualityTestFailed);
    XCTAssertTrue([[int64List list] int64AtIndex:1] == 20, DBUEqualityTestFailed);
    XCTAssertTrue(int64List.count == 2, DBUEqualityTestFailed);
    
    // allocate list<System.Single> and populate
    System_Collections_Generic_ListA1 *floatList = [System_Collections_Generic_ListA1 listWithObjects:@[DBNumFloat(11), DBNumFloat(12)]];
    [floatList add:[DBNumFloat(13) managedObject]];
    [floatList add:[DBNumFloat(14) managedObject]];
    XCTAssertTrue([[floatList list] floatAtIndex:2] == 13, DBUEqualityTestFailed);
    XCTAssertTrue([[floatList list] floatAtIndex:3] == 14, DBUEqualityTestFailed);
    XCTAssertTrue(floatList.count == 4, DBUEqualityTestFailed);
    
    // allocate list<System.Double> and populate
    System_Collections_Generic_ListA1 *doubleList = [System_Collections_Generic_ListA1 listWithObjects:@[DBNumDouble(21), DBNumDouble(22)]];
    [doubleList add:[DBNumDouble(23) managedObject]];
    [doubleList add:[DBNumDouble(24) managedObject]];
    XCTAssertTrue([[doubleList list] doubleAtIndex:2] == 23, DBUEqualityTestFailed);
    XCTAssertTrue([[doubleList list] doubleAtIndex:3] == 24, DBUEqualityTestFailed);
    XCTAssertTrue(doubleList.count == 4, DBUEqualityTestFailed);

    // allocate list<string> and populate
    NSString *item = @"item 0";
    System_Collections_Generic_ListA1 *stringList = [System_Collections_Generic_ListA1 listWithObjects:@[item, @"item 1"]];
    [stringList add:[@"item 2" managedString]];
    [stringList add:[@"item 3" managedString]];
    XCTAssertTrue(stringList.count == 4, DBUEqualityTestFailed);
    
    // create array representation and validate
    NSArray *stringArray = [stringList array];
    XCTAssertTrue(stringArray.count == 4, DBUEqualityTestFailed);
    XCTAssertTrue([stringArray[0] isEqualToString:item], DBUEqualityTestFailed);
    XCTAssertTrue([stringArray[3] isEqualToString:@"item 3"], DBUEqualityTestFailed);
    
    // derive ListA1 from array - the generic type parameter is derived from the first object in the array
    NSArray *stringArray2 = @[@"1", @"10", @"100", @"1000",];
    System_Collections_Generic_ListA1 *numbersList = [stringArray2 managedListA1];
    XCTAssertTrue(numbersList.count == 4, DBUEqualityTestFailed);

    // derive ListA1 from array with explicit generic type parameter class
    numbersList = [stringArray2 managedListA1WithTypeParameter:[System_String class]];
    XCTAssertTrue(numbersList.count == 4, DBUEqualityTestFailed);

    // derive ListA1 from array with explicit generic type parameter from object
    numbersList = [stringArray2 managedListA1WithTypeParameter:@"get type from me"];
    XCTAssertTrue(numbersList.count == 4, DBUEqualityTestFailed);
    
    // derive ListA1 from array with explicit generic type parameter from monoType
    monoObject = [@"get type from me" monoObject];
    monoType = [DBType monoTypeForMonoObject:monoObject];
    typeValue = [NSValue valueWithPointer:monoType];
    numbersList = [stringArray2 managedListA1WithTypeParameter:typeValue];
    XCTAssertTrue(numbersList.count == 4, DBUEqualityTestFailed);
    
    // allocate list<testClass> and populate
    id refObject1 = [testClass new];
    id refObject2 = [testClass new];
    System_Collections_Generic_ListA1 *refObjectList = [System_Collections_Generic_ListA1 listWithObjects:@[refObject1, refObject2]];
    XCTAssertTrue(refObjectList.count == 2, DBUEqualityTestFailed);
    
    NSArray *refObjectArray = [refObjectList array];
    XCTAssertTrue(refObjectArray.count == 2, DBUEqualityTestFailed);
    XCTAssertTrue([refObjectArray[0] isEqual:refObject1], DBUEqualityTestFailed);
    XCTAssertTrue([refObjectArray[1] isEqual:refObject2], DBUEqualityTestFailed);
    
    // test exception when add invalid type to generic collection
    NSLog(@"\n\nThe exception report below is expected and indicates a passed test designed to exercise the managed exception catching system.\n\n");
    BOOL genericParameterExceptionRaised = NO;
    @try {
        // this will cause a leak
        [refObjectList add:[@"I should raise" managedObject]];
    }
    @catch (NSException *exception) {
        genericParameterExceptionRaised = YES;
        
        NSLog(@"\n\nThe exception report above is expected and indicates a passed test .\n\n");

    }
    @finally {
        XCTAssertTrue(genericParameterExceptionRaised, DBUExceptionTestFailed);
    }
}

- (void)doTestForEquality:(id)refObject class:(Class)testClass
{
#pragma unused(testClass)

    // we should retrieve the same object here as we have class equality
    System_Object *object = [[testClass alloc] initWithMonoObject:[refObject monoObject]];
    XCTAssertTrue(refObject == object, DBUInequalityTestFailed);

    // we should retrieve another object here as we have class inequality
    System_Object *object1 = [[System_Object alloc] initWithMonoObject:[refObject monoObject]];
    
    XCTAssertTrue(refObject != object1, DBUInequalityTestFailed);
    XCTAssertTrue([refObject monoObject] == object1.monoObject, DBUEqualityTestFailed);
    XCTAssertTrue([refObject isEqual:object1], DBUEqualityTestFailed);
    
    // compare two separate instances of the same object
    System_Object *object2 = [self doTestConstructorsWithclass:testClass];
    System_Object *object3 = [self doTestConstructorsWithclass:testClass];
    XCTAssertTrue(object2 != object3, DBUInequalityTestFailed);
    XCTAssertTrue(object2.monoObject != object3.monoObject, DBUInequalityTestFailed);
    XCTAssertTrue([[(id)object2 stringProperty] isEqual:[(id)object3 stringProperty]], DBUEqualityTestFailed);
    XCTAssertTrue([object2 hash] == [object3 hash], DBUEqualityTestFailed);
    
    // inclusion of managed object equality testing is optional
    object2.testForManagedObjectEquality = YES;
    XCTAssertTrue([object2 isEqual:object3], DBUEqualityTestFailed);
    object2.testForManagedObjectEquality = NO;
    XCTAssertTrue(![object2 isEqual:object3], DBUEqualityTestFailed);
    
    // object equality is determined on the basis of the stringProperty.
    NSString *eProperty = [(id)object3 stringProperty];
    [(id)object3 setStringProperty:[NSString stringWithFormat:@"+%@", eProperty]];
    XCTAssertTrue([object2 hash] != [object3 hash], DBUInequalityTestFailed);
    XCTAssertTrue(![object2 isEqual:object3], DBUInequalityTestFailed);
    
    //
    // value type
    //
    System_Int16 *int16arg = [System_Int16 objectWithInt16:123];
    System_Int16 *int16arg2 = [System_Int16 objectWithInt16:123];
    System_Int16 *int16arg3 = [System_Int16 objectWithInt16:456];
    System_Int32 *int32arg = [System_Int32 objectWithInt32:456];

    // value comparison
    XCTAssertFalse([int16arg compareTo_withValueInt16:int16arg.db_int16Value], DBUInequalityTestFailed);
    XCTAssertTrue([int16arg compareTo_withValueObject:int16arg] == 0, DBUEqualityTestFailed);
    XCTAssertTrue([int16arg compareTo_withValueObject:int16arg2] == 0, DBUEqualityTestFailed);
    XCTAssertTrue([int16arg compareTo_withValueObject:int16arg3] < 0, DBUInequalityTestFailed);
    XCTAssertTrue([int16arg3 compareTo_withValueObject:int16arg2] > 0, DBUInequalityTestFailed);
    BOOL exceptionCaught = NO;
    @try {
        [int16arg3 compareTo_withValueObject:int32arg];
    }
    @catch (NSException *e) {
        exceptionCaught = YES;
    }
    XCTAssertTrue(exceptionCaught, DBUEqualityTestFailed);
    
    // value equality
    XCTAssertFalse([int16arg isEqual:@"not me".managedString], DBUInequalityTestFailed);
    XCTAssertTrue([int16arg isEqual:int16arg], DBUEqualityTestFailed);
    XCTAssertTrue([int16arg equals_withObjInt16:int16arg.db_int16Value], DBUEqualityTestFailed);
    XCTAssertFalse([int16arg equals_withObjObject:int32arg], DBUEqualityTestFailed);

    //
    // enum
    //
    DULongEnum_ *longEnum1 = [DULongEnum_ enumWithValue:Dubrovnik_UnitTests_LongEnum_val1];
    DULongEnum_ *longEnum1a = [DULongEnum_ enumWithValue:Dubrovnik_UnitTests_LongEnum_val1];
    DULongEnum_ *longEnum2 = [DULongEnum_ enumWithValue:Dubrovnik_UnitTests_LongEnum_val2];
    
    // enum comparison
    XCTAssertTrue([longEnum1 compareTo_withTarget:longEnum1] == 0, DBUEqualityTestFailed);
    XCTAssertTrue([longEnum1 compareTo_withTarget:longEnum2] < 0, DBUInequalityTestFailed);
    
    // enum equality
    XCTAssertFalse([longEnum1 isEqual:nil], DBUInequalityTestFailed);
    XCTAssertFalse([longEnum1 isEqual:@"not me".managedString], DBUInequalityTestFailed);
    XCTAssertTrue([longEnum1 isEqual:longEnum1], DBUEqualityTestFailed);
    XCTAssertTrue([longEnum1 isEqual:longEnum1a], DBUEqualityTestFailed);
    XCTAssertFalse([longEnum1 isEqual:longEnum2], DBUInequalityTestFailed);
    
    //
    // nullable equality
    //
    SNullableA1_ *nullableInt1 = [SNullableA1_ newNullableFromInt64:122];
    SNullableA1_ *nullableInt1a = [SNullableA1_ newNullableFromInt64:122];
    SNullableA1_ *nullableInt2 = [SNullableA1_ newNullableFromInt64:123];
    
    // nullable equality
    XCTAssertFalse([nullableInt1 isEqual:nil], DBUInequalityTestFailed);
    XCTAssertTrue([nullableInt1 isEqual:nullableInt1], DBUEqualityTestFailed);
    XCTAssertTrue([nullableInt1 isEqual:nullableInt1a], DBUEqualityTestFailed);
    XCTAssertFalse([nullableInt1 isEqual:nullableInt2], DBUInequalityTestFailed);
}

- (void)doTestFields:(id)refObject class:(Class)testClass
{
   
    //
    // class fields
    //
    if (YES) {
        // class string field
        NSString *classStringField = [testClass classStringField];
        XCTAssertTrue([classStringField dbTestString:DBUTestString], DBUSubstringTestFailed);
        
        // string setter
        classStringField = [classStringField stringByAppendingString:@" : modified"];
        [testClass setClassStringField:classStringField];
        XCTAssertTrue([[testClass classStringField] isEqualToString:classStringField], DBUEqualityTestFailed);
        
        // class int field
        [testClass setClassIntField:1]; // set initially otherwise test fails when called again
        int32_t classIntField = [testClass classIntField];
        XCTAssertTrue(classIntField == 1, DBUEqualityTestFailed);
        
        // int setter
        classIntField = 10;
        [testClass setClassIntField:classIntField];
        XCTAssertTrue([testClass classIntField] == classIntField, DBUEqualityTestFailed);
    }
    
    // class date field
    if (YES) {
        NSDate *classDateField = [testClass classDateField];
        NSDate *testDate = [NSDate dateWithString:@"2014-04-06 00:00:00 +0000"];
        XCTAssertTrue([classDateField compare:testDate] == NSOrderedSame, DBUEqualityTestFailed);
    }
    
    //
    // instance fields
    //
    
    // string field
    NSString *stringField = [refObject stringField];
    XCTAssertNotNil(stringField, DBUObjectIsNil);
    
    // string setter
    stringField = [stringField stringByAppendingString:@" : modified"];
    [refObject setStringField:stringField];
    XCTAssertTrue([[refObject stringField] isEqualToString:stringField], DBUEqualityTestFailed);
    
    // int field
    int32_t intField = [refObject intField];
    XCTAssertTrue(intField == 1, DBUEqualityTestFailed);
    
    // int setter
    intField = 10;
    [refObject setIntField:intField];
    XCTAssertTrue([refObject intField] == intField, DBUEqualityTestFailed);
    
    // date field
    if (YES) {
        NSDate *dateField = [refObject dateField];
        XCTAssertNotNil(dateField, DBUObjectIsNil);
    }
}

- (void)doTestExtensionMethods:(id)refObject class:(Class)testClass
{
    #pragma unused(testClass)
    
    //
    // extension methods
    //
    if ([refObject respondsToSelector:@selector(extensionString)]) {
        NSString *extensionString = [refObject extensionString];
        XCTAssertNotNil(extensionString, DBUObjectIsNil);
    }
}

- (void)doTestMethods:(id)refObject class:(Class)testClass
{
    
#pragma unused(testClass)
    
    //
    // string methods + overloads
    //
    NSString *stringMethod = [refObject stringMethod];
    XCTAssertNotNil(stringMethod, DBUObjectIsNil);
    
    NSString *stringMethod1 = [refObject stringMethod_withS1:@"1"];
    XCTAssertNotNil(stringMethod1, DBUObjectIsNil);
    
    NSString *stringMethodWithInt = [refObject stringMethod_withN:100];
    XCTAssertTrue([stringMethodWithInt dbTestString:@"100"], DBUSubstringTestFailed);
    
    // These two tests account for the overload situation where the managed method
    // parameter names match. In this case additional type information is appended to
    // the interleaved parameters to create a unique signature.
    NSString *stringMethod2 = [refObject stringMethod_withS1String:@"1" s2String:@"2"];
    XCTAssertNotNil(stringMethod2, DBUObjectIsNil);
    
    MonoString *monoString = mono_string_new(mono_domain_get(), "2");
    DBManagedObject *stringObj = [DBManagedObject objectWithMonoObject:(MonoObject *)monoString];
    NSString *stringMethod3 = [refObject stringMethod_withS1String:@"1" s2Object:stringObj];
    XCTAssertNotNil(stringMethod3, DBUObjectIsNil);
    
    //
    // date methods
    //
    NSDate *dateMethod = [refObject dateMethod_withD1:[NSDate date]];
    XCTAssertNotNil(dateMethod, DBUObjectIsNil);

    //
    // decimal methods
    //
    NSDecimalNumber *d1 = [NSDecimalNumber decimalNumberWithMantissa:111 exponent:0 isNegative:NO];
    NSDecimalNumber *d2 = [NSDecimalNumber decimalNumberWithMantissa:3 exponent:0 isNegative:NO];
    NSDecimalNumber *decimalProduct = [d1 decimalNumberByMultiplyingBy:d2];
    NSDecimalNumber *decimalMethodResult = [refObject decimalMultiplierMethod_withD1:d1 d2:d2];
    XCTAssertTrue([decimalMethodResult isEqual:decimalProduct], DBUEqualityTestFailed);

    //
    // nullable parameter methods
    //
    System_NullableA1 *nullableBool = [System_NullableA1 newNullableFromBool:YES];
    System_NullableA1 *nullableBoolResult = [refObject nullableBoolMethod_withP1:nullableBool];
    XCTAssertTrue([nullableBoolResult boolValue] == YES, DBUEqualityTestFailed);

    System_NullableA1 *nullableInt32 = [System_NullableA1 newNullableFromInt32:10995123];
    System_NullableA1 *nullableInt32Result = [refObject nullableInt32Method_withP1:nullableInt32];
    XCTAssertTrue([nullableInt32Result db_int32Value] == 10995123, DBUEqualityTestFailed);

    System_NullableA1 *nullableDouble = [System_NullableA1 newNullableFromDouble:33452.65672];
    System_NullableA1 *nullableDoubleResult = [refObject nullableDoubleMethod_withP1:nullableDouble];
    XCTAssertTrue([nullableDoubleResult doubleValue] == 33452.65672, DBUEqualityTestFailed);

    NSDecimalNumber *decimal = [NSDecimalNumber decimalNumberWithString:@"16782567776545.1278129"];
    System_NullableA1 *nullableDecimal = [System_NullableA1 newNullableFromDecimal:decimal];
    System_NullableA1 *nullableDecimalResult = [refObject nullableDecimalMethod_withP1:nullableDecimal];
    XCTAssertTrue([[nullableDecimalResult decimalNumberValue] isEqualToNumber:[nullableDecimal decimalNumberValue]], DBUEqualityTestFailed);
    
    NSDate *date = [NSDate date];
    System_NullableA1 *nullableDate = [System_NullableA1 newNullableFromDate:date];
    System_NullableA1 *nullableDateResult = [refObject nullableDateMethod_withP1:nullableDate];
    XCTAssertTrue([[nullableDateResult dateValue] isEqual:[nullableDate dateValue]], DBUEqualityTestFailed);
    XCTAssertTrue([[nullableDateResult dateValue] isEqual:[[date managedNullableA1] dateValue]], DBUEqualityTestFailed);
    
    //
    // mixed parameter methods
    //
    
    NSString *mixedMethod1 = [refObject mixedMethod1_withIntarg:1111 longArg:-2222 floatArg:33.33f doubleArg:-44.44 dateArg:[NSDate date] stringArg:@"GeneralTest" refObjectArg:refObject];
    XCTAssertTrue([mixedMethod1 dbTestString:DBUTestString], DBUSubstringTestFailed);
    XCTAssertTrue([mixedMethod1 dbTestString:@"1111"], DBUSubstringTestFailed);
    XCTAssertTrue([mixedMethod1 dbTestString:@"-2222"], DBUSubstringTestFailed);
    XCTAssertTrue([mixedMethod1 dbTestString:@"33.33"], DBUSubstringTestFailed);
    XCTAssertTrue([mixedMethod1 dbTestString:@"-44.44"], DBUSubstringTestFailed);
    XCTAssertTrue([mixedMethod1 dbTestString:@"GeneralTest"], DBUSubstringTestFailed);
    NSLog(@"%@", mixedMethod1);
    
    // TODO: mixed methods to cover all value types
    
    //
    // int methods
    //
    int32_t intToDouble = 1;
    int32_t intDoubled = [refObject doubleIt_withXInt:intToDouble];
    XCTAssertTrue(intDoubled == 2 * intToDouble, DBUEqualityTestFailed);
    
#if DB_VALUETYPE_BY_REFERENCE_SUPPORT == 1
    // value type by ref
    [refObject doubleIt_withXIntRef:&intToDouble];
    XCTAssertTrue(intDoubled == intToDouble, DBUEqualityTestFailed);
#endif
    
    //
    // Generic methods called on generic method definition of form Method<T>, Method<T,U> etc
    //
    if (!m_runningAutoGenCodeTest || YES) {
        
        // the object parameter can be any object that responds to -monoRTInvokeArg.
        // the type paramter can be passed as a native class, a System_type instance, a native instance with a corresponding monoObject *,
        // native NSValue containing a monoType *
        
        id genericResult = nil;
        
        //
        // One type parameter
        //
        
        // Method<string>()
        genericResult = [refObject genericMethod0_withTypeParameter:[System_String db_getType]];
        NSAssert([genericResult isKindOfClass:[NSString class]], DBUEqualityTestFailed);

        // Method<object>(object)
        // we define the generic method as <object>genericMethod1(<object>) and pass in a value type.
        // this is a crucial test when it comes to determing how value type arguments are passed in to the managed runtime
        // as the value type must remain boxed in this scenario.
        // At present the API unboxes all value types.
        // To override this behaviour when passing a boxed value type as System_Object we use the wrapper provided by
        // System_Value objectArg
        System_Boolean *boolObj = [System_Boolean objectWithBool:YES];
        genericResult = [refObject genericMethod1_withValue:boolObj.objectArg typeParameter:[System_Object class]];
        NSAssert([genericResult isKindOfClass:[DBNumber class]] && [(DBNumber *)genericResult boolValue] == YES, DBUEqualityTestFailed);
        
        // Method<string>(string)
        genericResult = [refObject genericMethod1_withValue:[DBUTestString managedObject] typeParameter:[System_String class]];
        NSAssert([genericResult isKindOfClass:[NSString class]] && [genericResult isEqualToString:DBUTestString], DBUEqualityTestFailed);
        
        genericResult = [refObject genericMethod1_withValue:DBUTestString.managedString typeParameter:[System_String db_getType]];
        NSAssert([genericResult isKindOfClass:[NSString class]] && [genericResult isEqualToString:DBUTestString], DBUEqualityTestFailed);
        
        genericResult = [refObject genericMethod1_withValue:DBUTestString.managedString typeParameter:@"a string"]; // get typeParameter from instance
        NSAssert([genericResult isKindOfClass:[NSString class]] && [genericResult isEqualToString:DBUTestString], DBUEqualityTestFailed);
        
        MonoType *monoType = [DBType monoTypeForMonoObject:[@"a string" monoObject]];
        genericResult = [refObject genericMethod1_withValue:DBUTestString.managedString typeParameter:[NSValue valueWithPointer:monoType]];
        NSAssert([genericResult isKindOfClass:[NSString class]] && [genericResult isEqualToString:DBUTestString], DBUEqualityTestFailed);
        
        // Method<int>(int)
        // value types will have to be unboxed for this invocation
        DBNumber *number = [DBNumber numberWithInt:101];
        genericResult = [refObject genericMethod1_withValue:number.managedObject typeParameter:[System_Int32 class]]; // explicit type parameter class
        NSAssert([genericResult isKindOfClass:[DBNumber class]] && [(DBNumber *)genericResult integerValue] == 101, DBUEqualityTestFailed);

        genericResult = [refObject genericMethod1_withValue:number.managedObject typeParameter:number]; // get typeParameter from instance
        NSAssert([genericResult isKindOfClass:[DBNumber class]] && [(DBNumber *)genericResult integerValue] == 101, DBUEqualityTestFailed);
        
        // Method<long>(long)
        number = [DBNumber numberWithLong:101];
        genericResult = [refObject genericMethod1_withValue:number.managedObject typeParameter:number]; // get typeParameter from instance
        NSAssert([genericResult isKindOfClass:[DBNumber class]] && [(DBNumber *)genericResult longValue] == 101, DBUEqualityTestFailed);
        
        // Method<float>(float)
        number = [DBNumber numberWithFloat:101.1f];
        genericResult = [refObject genericMethod1_withValue:number.managedObject typeParameter:number]; // get typeParameter from instance
        NSAssert([genericResult isKindOfClass:[DBNumber class]] && [(DBNumber *)genericResult floatValue] == 101.1f, DBUEqualityTestFailed);

        // Method<double>(double)
        number = [DBNumber numberWithDouble:101.1];
        genericResult = [refObject genericMethod1_withValue:number.managedObject typeParameter:number]; // get typeParameter from instance
        NSAssert([genericResult isKindOfClass:[DBNumber class]] && [(DBNumber *)genericResult doubleValue] == 101.1, DBUEqualityTestFailed);
        
        // Method<List<string>>(List<string>)
        System_Collections_Generic_ListA1 *listA1 = [@[@"A", @"B"] managedListA1];
        genericResult = [refObject genericMethod1_withValue:listA1 typeParameter:[listA1 db_getType]];
        NSAssert([genericResult isKindOfClass:[System_Collections_Generic_ListA1 class]], DBUEqualityTestFailed);
        
        // Method<List<T>>(List<T>)
        @try {
            genericResult = [refObject genericMethodList1_withValue:listA1 typeParameter:[System_String db_getType]];
            NSAssert([genericResult isKindOfClass:[NSString class]] && [genericResult isEqualToString:@"A"], DBUEqualityTestFailed);
        } @catch (NSException *e) {
#warning failing for auto bindings
        }
        
        //
        // Two type parameters
        //
        genericResult = [refObject genericMethod02_withTypeParameters:@[[System_String db_getType], [System_String db_getType]]];
        NSAssert([genericResult isKindOfClass:[NSString class]], DBUEqualityTestFailed);
        
        // Method<string,string>(string,string)
        System_Collections_Generic_DictionaryA2 *resultA2 = [refObject genericMethod2_withKey:@"key".managedString value:DBUTestString.managedString typeParameters:@[[System_String class], [System_String class]]];
        NSAssert([resultA2 isKindOfClass:[System_Collections_Generic_DictionaryA2 class]], DBUEqualityTestFailed);
        NSAssert([[resultA2 objectForKey:@"key"] isEqualToString:DBUTestString], DBUEqualityTestFailed);

        // Method<int,string>(int,string)
        DBNumber *numberKey = [DBNumber numberWithLong:101];
        resultA2 = [refObject genericMethod2_withKey:numberKey.managedObject value:DBUTestString.managedString typeParameters:@[number, [System_String class]]];
        NSAssert([resultA2 isKindOfClass:[System_Collections_Generic_DictionaryA2 class]], DBUEqualityTestFailed);
        NSAssert([[resultA2 objectForKey:numberKey] isEqualToString:DBUTestString], DBUEqualityTestFailed);
        
        // Method<string,int>(string,int)
        number = [DBNumber numberWithLong:101];
        resultA2 = [refObject genericMethod2_withKey:@"key".managedString value:number.managedObject typeParameters:@[[System_String class], number]];
        NSAssert([resultA2 isKindOfClass:[System_Collections_Generic_DictionaryA2 class]], DBUEqualityTestFailed);
        NSAssert([[resultA2 objectForKey:@"key"] isEqualTo:number], DBUEqualityTestFailed);
        
        // Method<int,int>(int,int)
        DBNumber *numberValue = [DBNumber numberWithLong:9052];
        resultA2 = [refObject genericMethod2_withKey:numberKey.managedObject value:numberValue.managedObject typeParameters:@[number, numberValue]];
        NSAssert([resultA2 isKindOfClass:[System_Collections_Generic_DictionaryA2 class]], DBUEqualityTestFailed);
        NSAssert([[resultA2 objectForKey:numberKey] isEqualTo:numberValue], DBUEqualityTestFailed);
        
        // Method<int,List<string>>(int,List<string>)
        resultA2 = [refObject genericMethod2_withKey:numberKey.managedObject value:listA1 typeParameters:@[number, listA1]];
        NSAssert([resultA2 isKindOfClass:[System_Collections_Generic_DictionaryA2 class]], DBUEqualityTestFailed);
        NSAssert([[resultA2 objectForKey:numberKey] isKindOfClass:[System_Collections_Generic_ListA1 class]], DBUEqualityTestFailed);
        
        //
        // static methods
        //
        
        // Method<string,string>(string,string)
        resultA2 = [DUReferenceObject_ genericMethodStatic2_withKey:@"key".managedString value:DBUTestString.managedString typeParameters:@[[System_String class], [System_String class]]];
        NSAssert([resultA2 isKindOfClass:[System_Collections_Generic_DictionaryA2 class]], DBUEqualityTestFailed);
        NSAssert([[resultA2 objectForKey:@"key"] isEqualToString:DBUTestString], DBUEqualityTestFailed);
        
        // Method<int,string>(int,string)
        numberKey = [DBNumber numberWithLong:101];
        resultA2 = [DUReferenceObject_ genericMethodStatic2_withKey:numberKey.managedObject value:DBUTestString.managedString typeParameters:@[number, [System_String class]]];
        NSAssert([resultA2 isKindOfClass:[System_Collections_Generic_DictionaryA2 class]], DBUEqualityTestFailed);
        NSAssert([[resultA2 objectForKey:numberKey] isEqualToString:DBUTestString], DBUEqualityTestFailed);
        
        // Method<string,int>(string,int)
        number = [DBNumber numberWithLong:101];
        resultA2 = [DUReferenceObject_ genericMethodStatic2_withKey:@"key".managedString value:number.managedObject typeParameters:@[[System_String class], number]];
        NSAssert([resultA2 isKindOfClass:[System_Collections_Generic_DictionaryA2 class]], DBUEqualityTestFailed);
        NSAssert([[resultA2 objectForKey:@"key"] isEqualTo:number], DBUEqualityTestFailed);
        
        // Method<int,int>(int,int)
        numberValue = [DBNumber numberWithLong:9052];
        resultA2 = [DUReferenceObject_ genericMethodStatic2_withKey:numberKey.managedObject value:numberValue.managedObject typeParameters:@[number, numberValue]];
        NSAssert([resultA2 isKindOfClass:[System_Collections_Generic_DictionaryA2 class]], DBUEqualityTestFailed);
        NSAssert([[resultA2 objectForKey:numberKey] isEqualTo:numberValue], DBUEqualityTestFailed);
        
        // Method<int,List<string>>(int,List<string>)
        resultA2 = [DUReferenceObject_ genericMethodStatic2_withKey:numberKey.managedObject value:listA1 typeParameters:@[number, listA1]];
        NSAssert([resultA2 isKindOfClass:[System_Collections_Generic_DictionaryA2 class]], DBUEqualityTestFailed);
        NSAssert([[resultA2 objectForKey:numberKey] isKindOfClass:[System_Collections_Generic_ListA1 class]], DBUEqualityTestFailed);
    }
    
    //
    // Generic type argument methods
    //
    System_Collections_Generic_ListA1 *list = [System_Collections_Generic_ListA1 listWithObjects:@[@"1", @"2"]];
    [refObject reverseList_withListSCGListA1string:list];
    NSArray *revList = [list array];
    NSAssert([revList[0] isEqualToString:@"2"], DBUEqualityTestFailed);
    NSAssert([revList[1] isEqualToString:@"1"], DBUEqualityTestFailed);
 
    System_Collections_Generic_ListA1 *intList = [System_Collections_Generic_ListA1 listWithObjects:@[DBNumInt(1), DBNumInt(2)]];
    [refObject reverseList_withListSCGListA1int:intList];
    revList = [intList array];
    NSAssert([revList[0] isEqualTo:@(2)], DBUEqualityTestFailed);
    NSAssert([revList[1] isEqualTo:@(1)], DBUEqualityTestFailed);
    
    System_Collections_Generic_ListA1 *list1 = [System_Collections_Generic_ListA1 listWithObjects:@[@"1", @"2"]];
    NSString *addList = [refObject addIEnumerable_withList:(id)list1];
    NSAssert([addList isEqualToString:@"12"], DBUEqualityTestFailed);
    
    //
    // static methods
    //
    NSString *classDescription = (NSString *)[testClass classDescription];
    XCTAssertTrue([classDescription dbTestString:DBUTestString], DBUSubstringTestFailed);
    
#if DB_RUN_AUTO_GENERATED_CODE_TEST == 1
    //
    // nested type parameters + overloads
    //
    if (m_runningAutoGenCodeTest) {
        Dubrovnik_UnitTests_ReferenceObject__NestedClass *nestedClass = [Dubrovnik_UnitTests_ReferenceObject__NestedClass new];
        [refObject nestedTypeParameter_withP1DUReferenceObject__NestedEnum:Dubrovnik_UnitTests_ReferenceObject__NestedEnum_val1];
        [refObject nestedTypeParameter_withP1DUReferenceObject__NestedClass:nestedClass];
        [refObject nestedTypeParameters_withP1:nestedClass p2:Dubrovnik_UnitTests_ReferenceObject__NestedEnum_val1];
        
        
        // and again, this time with generic types
        MonoImage *image = mono_assembly_get_image(monoAssembly);
        id nestedGenericClassA2 = [Dubrovnik_UnitTests_ReferenceObject__NestedGenericClassA2 newWithTypeParameters:@[[System_String class], [System_Int32 class]] monoImage:image];
        [refObject nestedTypeParameters_withPDUReferenceObject__NestedGenericClassA2string_int:nestedGenericClassA2];
        
        nestedGenericClassA2 = [Dubrovnik_UnitTests_ReferenceObject__NestedGenericClassA2 newWithTypeParameters:@[[System_Int32 class], [System_String class]] monoImage:image];
        [refObject nestedTypeParameters_withPDUReferenceObject__NestedGenericClassA2int_string:nestedGenericClassA2];
    }
#endif
}

- (void)doTestRefMethods:(id)refObject class:(Class)testClass
{
#pragma unused(testClass)
    
    NSString *s1 = DBUTestString;
    
    // pass string by reference
    [refObject stringMethodWithStringRef_withS1Ref:&s1];
    XCTAssertTrue([s1 isEqualToString:[DBUTestString stringByAppendingString:DBUTestString]], DBUEqualityTestFailed);
    
}

- (void)doTestPointerMethods:(id)refObject class:(Class)testClass
{
#pragma unused(testClass)
    
    // int 32 pointer
    int32_t x = 101, y = 202;
    int32_t int32Sum = [refObject sumAndSwitch_withIntPtrX:&x intPtrY:&y];
    XCTAssertTrue(int32Sum == x + y, DBUEqualityTestFailed);
    XCTAssertTrue(x == 202, DBUEqualityTestFailed);
    XCTAssertTrue(y == 101, DBUEqualityTestFailed);
    
    // int 64 pointer
    int64_t x64 = 202, y64 = 303;
    int64_t int64Sum = [refObject sumAndSwitch_withInt64PtrX:&x64 int64PtrY:&y64];
    XCTAssertTrue(int64Sum == x64 + y64, DBUEqualityTestFailed);
    XCTAssertTrue(x64 == 303, DBUEqualityTestFailed);
    XCTAssertTrue(y64 == 202, DBUEqualityTestFailed);
    
    // float pointer
    float xfloat = 404, yfloat = 505;
    float floatSum = [refObject sumAndSwitch_withFloatPtrX:&xfloat floatPtrY:&yfloat];
    XCTAssertTrue(floatSum == xfloat + yfloat, DBUEqualityTestFailed);
    XCTAssertTrue(xfloat == 505, DBUEqualityTestFailed);
    XCTAssertTrue(yfloat == 404, DBUEqualityTestFailed);
    
    // double pointer
    double xdouble = 606, ydouble = 772;
    double doubleSum = [refObject sumAndSwitch_withDoublePtrX:&xdouble doublePtrY:&ydouble];
    XCTAssertTrue(doubleSum == xdouble + ydouble, DBUEqualityTestFailed);
    XCTAssertTrue(xdouble == 772, DBUEqualityTestFailed);
    XCTAssertTrue(ydouble == 606, DBUEqualityTestFailed);
}


- (void)doTestArrayMethods:(id)refObject class:(Class)testClass
{
#pragma unused(testClass)
    
    // int 64 array
    NSArray *int64NSArray = @[@0L, @1L, @2L, @4L, @8L, @16L, @32L, @64L, @128L, @256L];
    System_Array *int64Array = [int64NSArray managedArrayWithTypeName:DBType_System_Int64];
    int64_t int64Total = [refObject sum_withInt64Array:int64Array];
    XCTAssertTrue(int64Total == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 256, DBUEqualityTestFailed);
    
    // int 32 array
    NSArray *int32NSArray = @[@0, @1, @2, @4, @8, @16, @32, @64, @128, @257];
    System_Array *int32Array = [int32NSArray managedArrayWithTypeName:DBType_System_Int32];
    int32_t int32Total = [refObject sum_withInt32Array:int32Array];
    XCTAssertTrue(int32Total == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 257, DBUEqualityTestFailed);
    
    // int 16 array
    NSArray *int16NSArray = @[@0, @1, @2, @4, @8, @16, @32, @64, @128, @255];
    System_Array *int16Array = [int16NSArray managedArrayWithTypeName:DBType_System_Int16];
    int16_t int16Total = [refObject sum_withInt16Array:int16Array];
    XCTAssertTrue(int16Total == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 255, DBUEqualityTestFailed);
    
    // byte array
    NSArray *byteNSArray = @[@0, @1, @2, @4, @8, @16, @32, @64];
    System_Array *byteArray = [byteNSArray managedArrayWithTypeName:DBType_System_Byte];
    int8_t byteTotal = [refObject sum_withByteArray:byteArray];
    XCTAssertTrue(byteTotal == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64, DBUEqualityTestFailed);
    
    // float array
    NSArray *floatNSArray = @[@0.0F, @1.0F, @2.0F, @4.0F, @8.0F, @16.0F, @32.0F, @64.0F, @128.0F, @258.0F];
    System_Array *floatArray = [floatNSArray managedArrayWithTypeName:DBType_System_Single];
    float floatTotal = [refObject sum_withFloatArray:floatArray];
    XCTAssertTrue(floatTotal == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 258, DBUEqualityTestFailed);
    
    // double array
    NSArray *doubleNSArray = @[@0.0, @1.0, @2.0, @4.0, @8.0, @16.0F, @32.0, @64.0, @128.0, @259.0];
    System_Array *doubleArray = [doubleNSArray managedArrayWithTypeName:DBType_System_Double];
    double doubleTotal = [refObject sum_withDoubleArray:doubleArray];
    XCTAssertTrue(doubleTotal == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 259, DBUEqualityTestFailed);
    
    // string array
    NSArray *stringNSArray = @[DBUTestString, @" 1", @" 2"];
    System_Array *stringArray = [stringNSArray managedArrayWithTypeName:DBType_System_String];
    NSString *stringTotal = [refObject sum_withStringArray:stringArray];
    NSString *stringTest = [NSString stringWithFormat:@"%@ %@ %@", DBUTestString, @"1", @"2"];
    XCTAssertTrue([stringTotal isEqual:stringTest], DBUEqualityTestFailed);
}

- (void)doTestPointerProperties:(id)refObject class:(Class)testClass
{
#pragma unused(testClass)
    
    // IntPtr pointer
    NSString *stringPointer = @"It's okay to point at me like that.";
    [refObject setPointer:(__bridge void *)(stringPointer)];
    void *voidPtr = [refObject pointer];
    XCTAssertTrue(voidPtr == (__bridge void *)stringPointer, DBUEqualityTestFailed);
    
    // int32 pointer
    int32_t theInt = 10101;
    voidPtr = &theInt;
    [refObject setPointer:voidPtr];
    voidPtr = [refObject pointer];
    XCTAssertTrue(voidPtr == &theInt, DBUEqualityTestFailed);
    XCTAssertTrue(*(int32_t *)voidPtr == theInt, DBUEqualityTestFailed);
    
#warning TODO test always failing on Mono 4.6+
    /*
    [refObject setInt32Pointer:&theInt];
    int32_t *int32Pointer = [refObject int32Pointer];
    XCTAssertTrue(int32Pointer == &theInt, DBUEqualityTestFailed);
    XCTAssertTrue(*int32Pointer == theInt, DBUEqualityTestFailed);
     */
}

- (void)doTestPropertyPersistence:(id)refObject class:(Class)testClass
{
#pragma unused(refObject, testClass)

    // repeated calls to a property should return the same object
    // unless the setter has been called or the property has been changed
    // by a managed code, most likely as a side effect
#warning TODO: test property persistence for generated code
    
}

- (void)doTestArrayProperties:(id)refObject class:(Class)testClass
{
#pragma unused(testClass)
    
    // string array
    System_Array *stringArray = [refObject stringArray];
    XCTAssertTrue([stringArray count] == 3, DBUCountTestFailed);
    
    NSMutableString *ms = [NSMutableString new];
    for (uint32_t i = 0; i < [stringArray count]; i++) {
        NSString * s = [stringArray objectAtIndex:i];
        [ms appendFormat:@"%@ ", s];
    }
    XCTAssertTrue([ms dbTestString:DBUTestString], DBUSubstringTestFailed);
    
    // derive string mono array from NSArray
    NSArray *stringNSArray = @[DBUTestString, @"1", @"2"];
    stringArray = [stringNSArray managedArrayWithTypeName:DBType_System_String];
    [refObject setStringArray:stringArray];   // set
    stringArray = [refObject stringArray];    // get
    XCTAssertTrue([stringArray count] == 3, DBUCountTestFailed);
    ms = [NSMutableString new];
    for (uint32_t i = 0; i < [stringArray count]; i++) {
        NSString * s = [stringArray objectAtIndex:i];
        [ms appendFormat:@"%@ ", s];
    }
    XCTAssertTrue([ms dbTestString:DBUTestString], DBUSubstringTestFailed);
    
    // int64 array
    System_Array *int64Array = [(DUReferenceObject_ *)refObject int64Array];
    XCTAssertTrue([int64Array count] == 10, DBUCountTestFailed);
    
    int64_t n = 0;
    for (uint32_t i = 0; i < [int64Array count]; i++) {
        n += [int64Array int64AtIndex:i];
    }
    XCTAssertTrue(n == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 256, DBUEqualityTestFailed);

    // mutate the property array
    [int64Array setInt64AtIndex:[int64Array count] - 1 value:1];
    [refObject setInt64Array:int64Array];   // set
    int64Array = [(DUReferenceObject_ *)refObject int64Array];    // get
    XCTAssertTrue([int64Array count] == 10, DBUCountTestFailed);
    n = 0;
    for (uint32_t i = 0; i < [int64Array count]; i++) {
        n += [int64Array int64AtIndex:i];
    }
    XCTAssertTrue(n == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 1, DBUEqualityTestFailed);
    
    // derive 64 bit mono array from NSArray
    NSArray *int64NSArray = @[@0L, @1L, @2L, @4L, @8L, @16L, @32L, @64L, @128L, @128L];
    int64Array = [int64NSArray managedArrayWithTypeName:DBType_System_Int64];
    [refObject setInt64Array:int64Array];   // set
    int64Array = [(DUReferenceObject_ *)refObject int64Array];    // get
    XCTAssertTrue([int64Array count] == 10, DBUCountTestFailed);
    n = 0;
    for (uint32_t i = 0; i < [int64Array count]; i++) {
      n += [int64Array int64AtIndex:i];
    }
    XCTAssertTrue(n == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 128, DBUEqualityTestFailed);

    // int32 array
    System_Array *int32Array = [(DUReferenceObject_ *)refObject int32Array];
    XCTAssertTrue([int32Array count] == 10, DBUCountTestFailed);
    
    n = 0;
    for (uint32_t i = 0; i < [int32Array count]; i++) {
        n += [int32Array int32AtIndex:i];
    }
    XCTAssertTrue(n == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 256, DBUEqualityTestFailed);

    // derive 32 bit mono array from NSArray
    NSArray *int32NSArray = @[@0, @1, @2, @4, @8, @16, @32, @64, @128, @120];
    int32Array = [int32NSArray managedArrayWithTypeName:DBType_System_Int32];
    [refObject setInt32Array:int32Array];   // set
    int32Array = [(DUReferenceObject_ *)refObject int32Array];    // get
    XCTAssertTrue([int32Array count] == 10, DBUCountTestFailed);
    n = 0;
    for (uint32_t i = 0; i < [int32Array count]; i++) {
        n += [int32Array int32AtIndex:i];
    }
    XCTAssertTrue(n == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 120, DBUEqualityTestFailed);
    
    // int16 array
    System_Array *int16Array = [(DUReferenceObject_ *)refObject int16Array];
    XCTAssertTrue([int16Array count] == 10, DBUCountTestFailed);
    
    n = 0;
    for (uint32_t i = 0; i < [int16Array count]; i++) {
        n += [int16Array int16AtIndex:i];
    }
    XCTAssertTrue(n == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 256, DBUEqualityTestFailed);
    
    // float array
    System_Array *floatArray = [(DUReferenceObject_ *)refObject floatArray];
    XCTAssertTrue([floatArray count] == 10, DBUCountTestFailed);
    
    float f = 0;
    for (uint32_t i = 0; i < [floatArray count]; i++) {
        f += [floatArray floatAtIndex:i];
    }
    XCTAssertTrue(f == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 256, DBUEqualityTestFailed);

    // derive float mono array from NSArray
    NSArray *floatNSArray = @[@0.0F, @1.0F, @2.0F, @4.0F, @8.0F, @16.0F, @32.0F, @64.0F, @128.0F, @116.0F];
    floatArray = [floatNSArray managedArrayWithTypeName:DBType_System_Single];
    [refObject setFloatArray:floatArray];   // set
    floatArray = [(DUReferenceObject_ *)refObject floatArray];    // get
    XCTAssertTrue([floatArray count] == 10, DBUCountTestFailed);
    n = 0;
    for (uint32_t i = 0; i < [floatArray count]; i++) {
        n += [floatArray floatAtIndex:i];
    }
    XCTAssertTrue(n == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 116, DBUEqualityTestFailed);
    
    // double array
    System_Array *doubleArray = [(DUReferenceObject_ *)refObject doubleArray];
    XCTAssertTrue([doubleArray count] == 10, DBUCountTestFailed);
    
    double d = 0;
    for (uint32_t i = 0; i < [doubleArray count]; i++) {
        d += [doubleArray doubleAtIndex:i];
    }
    XCTAssertTrue(d == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 256, DBUEqualityTestFailed);

    // derive double mono array from NSArray
    NSArray *doubleNSArray = @[@0.0, @1.0, @2.0, @4.0, @8.0, @16.0, @32.0, @64.0, @128.0, @110.0];
    doubleArray = [doubleNSArray managedArrayWithTypeName:DBType_System_Double];
    [refObject setDoubleArray:doubleArray];   // set
    doubleArray = [(DUReferenceObject_ *)refObject doubleArray];    // get
    XCTAssertTrue([doubleArray count] == 10, DBUCountTestFailed);
    n = 0;
    for (uint32_t i = 0; i < [doubleArray count]; i++) {
        n += [doubleArray doubleAtIndex:i];
    }
    XCTAssertTrue(n == 0 + 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 110, DBUEqualityTestFailed);
    
    // bool array
    System_Array *boolArray = [(DUReferenceObject_ *)refObject boolArray];
    XCTAssertTrue([boolArray count] == 10, DBUCountTestFailed);
    
    for (uint32_t i = 0; i < [boolArray count]; i++) {
        bool b = [boolArray boolAtIndex:i];
        XCTAssertTrue(b == (i % 2 == 0 ? YES : NO), DBUEqualityTestFailed);
    }
}

- (void)doTestNotifyingProperties:(id)refObject class:(Class)testClass
{
#pragma unused(testClass)
    
    [refObject setNotifyingProperty1:DBUTestString];
    [refObject setNotifyingProperty2:DBUTestString];
    
}

- (void)doTestGenericMethods:(id)refObject class:(Class)testClass
{
#pragma unused(refObject)
#pragma unused(testClass)
}

- (void)doTestGenericProperties:(id)refObject class:(Class)testClass
{
#pragma unused(testClass)
    
#warning TODO: add tests for all possible List<T> types
#warning TODO: add tests for -orderedDictionary
#warning TODO: add tests for -deepDictionary
    
    // List<string>
    System_Collections_Generic_ListA1 *listOfStrings = [refObject stringList];
    NSArray<NSString *> *arrayOfStrings = [listOfStrings array];
    XCTAssertTrue([arrayOfStrings[0] dbTestString:DBUTestString], DBUSubstringTestFailed);
    XCTAssertTrue([arrayOfStrings[0] dbTestString:@" 1"], DBUSubstringTestFailed);
    XCTAssertTrue([arrayOfStrings[1] dbTestString:DBUTestString], DBUSubstringTestFailed);
    XCTAssertTrue([arrayOfStrings[1] dbTestString:@" 2"], DBUSubstringTestFailed);
    
    // List<NestedClass>
    System_Collections_Generic_ListA1 *nestedClassListA1 = [refObject nestedClassList];
    NSArray<id> *nestedClassArray = [nestedClassListA1 array];
    XCTAssertTrue([[nestedClassArray[0] stringProperty] dbTestString:@"Dubrovnik.UnitTests 1"], DBUSubstringTestFailed);
    XCTAssertTrue([[nestedClassArray[1] stringProperty] dbTestString:@"Dubrovnik.UnitTests 2"], DBUSubstringTestFailed);
    [nestedClassArray managedListA1]; // reverse the process
    
    // An aside
    // The reflection format for nested class is Dubrovnik.UnitTests.ReferenceObject+NestedClass
    // THE CTS/IL format is Dubrovnik.UnitTests.ReferenceObject/NestedClass
    System_Object *s = nestedClassArray[0];
    const char *sname = s.monoTypeName; // this evaluates to Dubrovnik.UnitTests.ReferenceObject.NestedClass"
    (void)sname; // keep the compiler quiet
    
    // List<int>
    System_Collections_Generic_ListA1 *listOfInts = [refObject intList];
    NSArray *arrayOfInts = [listOfInts array];
    XCTAssertTrue([arrayOfInts count] == 3, DBUCountTestFailed);
    XCTAssertTrue([arrayOfInts[0] intValue] == 1, DBUEqualityTestFailed);
    XCTAssertTrue([arrayOfInts[1] intValue] == -10, DBUEqualityTestFailed);
    XCTAssertTrue([arrayOfInts[2] intValue] == 100, DBUEqualityTestFailed);

    // List<uint>
    System_Collections_Generic_ListA1 *listOfUInts = [refObject uIntList];
    NSArray *arrayOfUInts = [listOfUInts array];
    XCTAssertTrue([arrayOfUInts count] == 2, DBUCountTestFailed);
    XCTAssertTrue([arrayOfUInts[0] unsignedIntValue] == 2, DBUEqualityTestFailed);
    XCTAssertTrue([arrayOfUInts[1] unsignedIntValue] == 20, DBUEqualityTestFailed);

    // List<float>
    System_Collections_Generic_ListA1 *listOfFloats = [refObject floatList];
    NSArray *arrayOfFloats = [listOfFloats array];
    XCTAssertTrue([arrayOfFloats count] == 3, DBUCountTestFailed);
    XCTAssertTrue([arrayOfFloats[0] floatValue] == 1., DBUEqualityTestFailed);
    XCTAssertTrue([arrayOfFloats[1] floatValue] == 2., DBUEqualityTestFailed);
    XCTAssertTrue([arrayOfFloats[2] floatValue] == 3., DBUEqualityTestFailed);
    
    // List<double>
    System_Collections_Generic_ListA1 *listOfDoubles = [refObject doubleList];
    NSArray *arrayOfDoubles = [listOfDoubles array];
    XCTAssertTrue([arrayOfDoubles count] == 2, DBUCountTestFailed);
    XCTAssertTrue([arrayOfDoubles[0] doubleValue] == 11., DBUEqualityTestFailed);
    XCTAssertTrue([arrayOfDoubles[1] doubleValue] == 22., DBUEqualityTestFailed);
    
    
    //============================
    // Dictionary<string,string>
    //=============================
    System_Collections_Generic_DictionaryA2 *stringStringDictA2 = [refObject stringStringDictionary];
    
    // test all keys
    NSArray *stringStringDictKeys = [stringStringDictA2 allKeys];
    XCTAssertTrue([stringStringDictKeys count] == 2, DBUCountTestFailed);
    XCTAssertTrue([stringStringDictKeys containsObject:@"keyForString1"], DBUObjectNotFound);
    XCTAssertTrue([stringStringDictKeys containsObject:@"keyForString2"], DBUObjectNotFound);
    
    // test all values
    NSArray *stringStringDictValues = [stringStringDictA2 allValues];
    XCTAssertTrue([stringStringDictValues count] == 2, DBUCountTestFailed);
    XCTAssertTrue([stringStringDictValues containsObject:@"Dubrovnik.UnitTests 1"], DBUObjectNotFound);
    XCTAssertTrue([stringStringDictValues containsObject:@"Dubrovnik.UnitTests 2"], DBUObjectNotFound);
    
    // test keys and values
    id key = stringStringDictKeys[0];
    id value = [stringStringDictA2 objectForKey:key];
    XCTAssertTrue([value dbTestString:@"1"], DBUSubstringTestFailed);
    key = stringStringDictKeys[1];
    XCTAssertTrue([[stringStringDictA2 objectForKey:key] dbTestString:@"2"], DBUSubstringTestFailed);
    
    // test keys and values using managed indexer exposed as get_Item_withKey
    value = [stringStringDictA2 get_Item_withKey:[@"keyForString1" managedString]];
    XCTAssertTrue([value dbTestString:@"1"], DBUSubstringTestFailed);
    value = [stringStringDictA2 get_Item_withKey:[@"keyForString2" managedString]];
    XCTAssertTrue([value dbTestString:@"2"], DBUSubstringTestFailed);
    
    // test NSDictionary representation
    NSDictionary *stringStringDict = [stringStringDictA2 dictionary];
    XCTAssertTrue([stringStringDict[@"keyForString1"] dbTestString:@"Dubrovnik.UnitTests 1"], DBUSubstringTestFailed);
    XCTAssertTrue([stringStringDict[@"keyForString2"] dbTestString:@"Dubrovnik.UnitTests 2"], DBUSubstringTestFailed);

    //============================
    // Dictionary<int,int>
    //=============================
    System_Collections_Generic_DictionaryA2 *intIntDictA2 = [refObject intIntDictionary];
    
    // test all keys
    NSArray *intIntDictKeys = [intIntDictA2 allKeys];
    XCTAssertTrue([intIntDictKeys count] == 2, DBUCountTestFailed);
    XCTAssertTrue([intIntDictKeys containsObject:@1], DBUObjectNotFound);
    XCTAssertTrue([intIntDictKeys containsObject:@3], DBUObjectNotFound);

    // test all values
    NSArray *intIntDictValues = [intIntDictA2 allValues];
    XCTAssertTrue([intIntDictValues count] == 2, DBUCountTestFailed);
    XCTAssertTrue([intIntDictValues containsObject:@2], DBUObjectNotFound);
    XCTAssertTrue([intIntDictValues containsObject:@6], DBUObjectNotFound);

    // test keys and values
    key = intIntDictKeys[0];
    value = [intIntDictA2 objectForKey:key];
    XCTAssertTrue([value intValue] == 2, DBUEqualityTestFailed);

    // test using managed indexer exposed as get_Item_withKey:
#warning need to look at this. it calls - (id)bestObjectWithMonoObject: so we have a method advertised as System_Object returning a DBNumber as -bestObjectWithMonoObject: prefers to package managed numerics as an NSNumber subclass as opposed to say a System_Int.
    DBNumber *valNumber = (DBNumber *)[intIntDictA2 get_Item_withKey:[DBNumber numberWithInt:3].managedObject];
    XCTAssertTrue([valNumber intValue] == 6, DBUEqualityTestFailed);
    
    // key is a DBManagedObject containing a boxed int
    int intKey = [intIntDictKeys[1] intValue];
    value = [intIntDictA2 objectForKey:[DBManagedObject objectWithMonoObject:DB_BOX_INT32(intKey)]];
    XCTAssertTrue([value intValue] == 6, DBUEqualityTestFailed);
    
    // key is a DBNumber representing an int
    value = [intIntDictA2 objectForKey:[DBNumber numberWithInt:intKey]];
    XCTAssertTrue([value intValue] == 6, DBUEqualityTestFailed);
    
    // object for key requires a type that represents a mono type
    BOOL numberTypeExceptionRaised = NO;
    @try {
        value = [intIntDictA2 objectForKey:@(intKey)];
    }
    @catch (NSException *e) {
        numberTypeExceptionRaised = YES;
    }
    @finally {
        XCTAssertTrue(numberTypeExceptionRaised, DBUExceptionTestFailed);
    }

    // key is a literal number representing an int
    NSNumber *literalNumberKey = [@((int)intKey) dbNumberFromIntValue];
    const char *typeEncoding = [literalNumberKey objCType];
    XCTAssertTrue(strcmp(typeEncoding, @encode(int)) == 0, DBUEqualityTestFailed);
    value = [intIntDictA2 objectForKey:literalNumberKey];
    XCTAssertTrue([value intValue] == 6, DBUEqualityTestFailed);
    
    // test NSDictionary representation
    NSDictionary *intIntDict = [intIntDictA2 dictionary];
    XCTAssertTrue([intIntDict[@(1)] intValue] == 2, DBUEqualityTestFailed);
    XCTAssertTrue([intIntDict[@(3)] intValue] == 6, DBUEqualityTestFailed);

    //============================
    // Dictionary<string,object>
    //=============================
    System_Collections_Generic_DictionaryA2 *stringObjectDictA2 = [refObject stringObjectDictionary];
    
    // test all keys
    NSArray *stringObjectDictKeys = [stringObjectDictA2 allKeys];
    XCTAssertTrue([stringObjectDictKeys count] == 7, DBUCountTestFailed);
    XCTAssertTrue([stringObjectDictKeys containsObject:@"keyForString"], DBUObjectNotFound);
    XCTAssertTrue([stringObjectDictKeys containsObject:@"keyForInteger"], DBUObjectNotFound);
    XCTAssertTrue([stringObjectDictKeys containsObject:@"keyForFloat"], DBUObjectNotFound);
    XCTAssertTrue([stringObjectDictKeys containsObject:@"keyForIntEnum"], DBUObjectNotFound);
    XCTAssertTrue([stringObjectDictKeys containsObject:@"keyForListA1"], DBUObjectNotFound);
    XCTAssertTrue([stringObjectDictKeys containsObject:@"keyForDictionaryA2"], DBUObjectNotFound);
    XCTAssertTrue([stringObjectDictKeys containsObject:@"keyForStringArray"], DBUObjectNotFound);
    
    // test all values
    NSArray *stringObjectDictValues = [stringObjectDictA2 allValues];
    XCTAssertTrue([stringObjectDictValues count] == 7, DBUCountTestFailed);
    
    XCTAssertTrue([stringObjectDictValues containsObject:@"Dubrovnik.UnitTests"], DBUObjectNotFound);
    XCTAssertTrue([stringObjectDictValues containsObject:@100], DBUObjectNotFound);
    XCTAssertTrue([stringObjectDictValues containsObject:@1001.], DBUObjectNotFound);

    // test all DictionaryA2 values for keys
    value = [stringObjectDictA2 objectForKey:@"keyForString"];
    XCTAssertTrue([value dbTestString:@"Dubrovnik.UnitTests"], DBUObjectNotFound);

    value = [stringObjectDictA2 objectForKey:@"keyForInteger"];
    XCTAssertTrue([value intValue] == 100, DBUObjectNotFound);

    value = [stringObjectDictA2 objectForKey:@"keyForFloat"];
    XCTAssertTrue([value intValue] == 1001., DBUObjectNotFound);

    value = [stringObjectDictA2 objectForKey:@"keyForIntEnum"];
    XCTAssertTrue([value intValue] == 1, DBUObjectNotFound);

    // ListA1 object
    value = [stringObjectDictA2 objectForKey:@"keyForListA1"];
    XCTAssertTrue([value isKindOfClass:[System_Collections_Generic_ListA1 class]], DBUClassEqualityTestFailed);

    NSArray *keyListA1Array = [(System_Collections_Generic_ListA1 *)value array];
    XCTAssertTrue([keyListA1Array containsObject:@"Dubrovnik1"], DBUObjectNotFound);
    XCTAssertTrue([keyListA1Array containsObject:@"Dubrovnik2"], DBUObjectNotFound);

    // DictionaryA2 object
    value = [stringObjectDictA2 objectForKey:@"keyForDictionaryA2"];
    XCTAssertTrue([value isKindOfClass:[System_Collections_Generic_DictionaryA2 class]], DBUClassEqualityTestFailed);

    XCTAssertTrue([(System_Collections_Generic_DictionaryA2 *)value objectForKey:@"subKey1"], DBUObjectNotFound);
    XCTAssertTrue([(System_Collections_Generic_DictionaryA2 *)value objectForKey:@"subKey2"], DBUObjectNotFound);
    XCTAssertFalse([(System_Collections_Generic_DictionaryA2 *)value objectForKey:@"subKeyN"], DBUDesignedToFailTestPassed);

    //  new string[] object
    System_Array *subItemDBArray = [stringObjectDictA2 objectForKey:@"keyForStringArray"];
    NSArray *subItemArray = [subItemDBArray array];
    XCTAssertTrue([subItemArray containsObject:@"Dubrovnik SubItem1"], DBUObjectNotFound);
    XCTAssertTrue([subItemArray containsObject:@"Dubrovnik SubItem2"], DBUObjectNotFound);
    XCTAssertFalse([subItemArray containsObject:@"Dubrovnik SubItem3"], DBUDesignedToFailTestPassed);
    
    //============================
    // Dictionary<object,object>
    //=============================
    System_Collections_Generic_DictionaryA2 *objectObjectDictA2 = [refObject objectObjectDictionary];

    // test all keys
    NSArray *objectObjectDictKeys = [objectObjectDictA2 allKeys];
    XCTAssertTrue([objectObjectDictKeys count] == 5, DBUCountTestFailed);

    XCTAssertTrue([objectObjectDictKeys containsObject:@"keyForString"], DBUObjectNotFound);
    XCTAssertTrue([objectObjectDictKeys containsObject:@"keyForInteger"], DBUObjectNotFound);
    XCTAssertTrue([objectObjectDictKeys containsObject:@"keyForFloat"], DBUObjectNotFound);
    XCTAssertTrue([objectObjectDictKeys containsObject:@1], DBUObjectNotFound);
    XCTAssertTrue([objectObjectDictKeys containsObject:[DBNumber numberWithFloat:1]], DBUObjectNotFound);
    
    // test all values
    NSArray *objectObjectDictValues = [objectObjectDictA2 allValues];
    XCTAssertTrue([objectObjectDictValues count] == 5, DBUCountTestFailed);
 
    XCTAssertTrue([objectObjectDictValues containsObject:@"Dubrovnik.UnitTests"], DBUObjectNotFound);
    XCTAssertTrue([objectObjectDictValues containsObject:@100], DBUObjectNotFound);
    XCTAssertTrue([objectObjectDictValues containsObject:@1001.F], DBUObjectNotFound);
    XCTAssertTrue([objectObjectDictValues containsObject:@8], DBUObjectNotFound);
    XCTAssertTrue([objectObjectDictValues containsObject:@"Dubrovnik.UnitTests 2"], DBUObjectNotFound);

    // test all DictionaryA2 values for keys
    value = [objectObjectDictA2 objectForKey:@"keyForString"];
    XCTAssertTrue(value && [value isKindOfClass:[NSString class]] && [value isEqual:@"Dubrovnik.UnitTests"], DBUObjectNotFound);
    
    value = [objectObjectDictA2 objectForKey:@"keyForInteger"];
    XCTAssertTrue(value && [value isKindOfClass:[NSNumber class]] && [value isEqual:@100], DBUObjectNotFound);
    
    value = [objectObjectDictA2 objectForKey:@"keyForFloat"];
    XCTAssertTrue(value && [value isKindOfClass:[NSNumber class]] && [value isEqual:@1001.F], DBUObjectNotFound);
    
    value = [objectObjectDictA2 objectForKey:[@1 dbNumberFromIntValue]];   // key must be a managed number
    XCTAssertTrue(value && [value isKindOfClass:[NSNumber class]] && [value isEqual:@8], DBUObjectNotFound);

    value = [objectObjectDictA2 objectForKey:[@1 dbNumberFromFloatValue]]; // key must be a managed number
    XCTAssertTrue(value && [value isKindOfClass:[NSString class]] && [value isEqual:@"Dubrovnik.UnitTests 2"], DBUObjectNotFound);

    // test all NSDictionary values for keys
    NSDictionary *objectObjectDict = [objectObjectDictA2 dictionary];
    XCTAssertTrue([objectObjectDict count] == 5, DBUCountTestFailed);
    
    value = [objectObjectDict objectForKey:@"keyForString"];
    XCTAssertTrue(value && [value isKindOfClass:[NSString class]] && [value isEqual:@"Dubrovnik.UnitTests"], DBUObjectNotFound);
    
    value = [objectObjectDict objectForKey:@"keyForInteger"];
    XCTAssertTrue(value && [value isKindOfClass:[NSNumber class]] && [value isEqual:@100], DBUObjectNotFound);
    
    value = [objectObjectDict objectForKey:@"keyForFloat"];
    XCTAssertTrue(value && [value isKindOfClass:[NSNumber class]] && [value isEqual:@1001.F], DBUObjectNotFound);

    // these are subtle tests that indicate that Dictionary<K,V> keys are type sensitive.
    // managed int 1 and float 1 are different keys.
    // to access a key which has a type duplicate in an NSDictionary use a DBNumber as shown.
    
    // NSNumber access will fail
    value = [objectObjectDict objectForKey:@1];
    XCTAssertNil(value, DBUNilTestFailed);

    DBNumber *managedKey = [@1 dbNumberFromIntValue];
    [managedKey setCompareEnforcesTypeMatch];
    
    value = [objectObjectDict objectForKey:managedKey];
    XCTAssertTrue(value && [value isKindOfClass:[NSNumber class]] && [value isEqual:@8], DBUObjectNotFound);

    managedKey = [@1 dbNumberFromFloatValue];
    [managedKey setCompareEnforcesTypeMatch];

    value = [objectObjectDict objectForKey:managedKey]; // key must be a managed number
    XCTAssertTrue(value && [value isKindOfClass:[NSString class]] && [value isEqual:@"Dubrovnik.UnitTests 2"], DBUObjectNotFound);
    
    //=======================================
    // Dictionary<int,Dictionary<int,string>>
    //=======================================
    System_Collections_Generic_DictionaryA2 *intIntStringDictA2 = [refObject intIntStringDictionaryDictionary];
    
    // test all keys
    NSArray *intIntStringDictDictKeys = [intIntStringDictA2 allKeys];
    XCTAssertTrue([intIntStringDictDictKeys count] == 2, DBUCountTestFailed);
    XCTAssertTrue([intIntStringDictDictKeys containsObject:@0], DBUObjectNotFound);
    XCTAssertTrue([intIntStringDictDictKeys containsObject:@1], DBUObjectNotFound);

    // sub dict 1
    System_Collections_Generic_DictionaryA2 *subDict1 = [intIntStringDictA2 objectForKey:[@0 dbNumberFromIntValue]];
    
    // test all keys
    NSArray *subDict1Keys = [subDict1 allKeys];
    XCTAssertTrue([subDict1Keys count] == 2, DBUCountTestFailed);
    XCTAssertTrue([subDict1Keys containsObject:@0], DBUObjectNotFound);
    XCTAssertTrue([subDict1Keys containsObject:@1], DBUObjectNotFound);

    // test all values
    NSString *stringValue = [subDict1 objectForKey:[@0 dbNumberFromIntValue]];
    XCTAssertTrue([stringValue isEqualToString:@"string0"], DBUEqualityTestFailed);

    stringValue = [subDict1 objectForKey:[@1 dbNumberFromIntValue]];
    XCTAssertTrue([stringValue isEqualToString:@"string1"], DBUEqualityTestFailed);
    
    // sub dict 2
    System_Collections_Generic_DictionaryA2 *subDict2 = [intIntStringDictA2 objectForKey:[@1 dbNumberFromIntValue]];
    
    // test all keys
    NSArray *subDict2Keys = [subDict2 allKeys];
    XCTAssertTrue([subDict2Keys count] == 2, DBUCountTestFailed);
    XCTAssertTrue([subDict2Keys containsObject:@10], DBUObjectNotFound);
    XCTAssertTrue([subDict2Keys containsObject:@11], DBUObjectNotFound);

    // test all values
    stringValue = [subDict2 objectForKey:[@10 dbNumberFromIntValue]];
    XCTAssertTrue([stringValue isEqualToString:@"string10"], DBUEqualityTestFailed);
    
    stringValue = [subDict2 objectForKey:[@11 dbNumberFromIntValue]];
    XCTAssertTrue([stringValue isEqualToString:@"string11"], DBUEqualityTestFailed);
    
    //============================
    // System.Nullable<T>
    //=============================
    
    // integer
    System_NullableA1 *intNullable = [refObject intNullable];
    XCTAssertTrue(intNullable != nil, DBUNotNilTestFailed);
    XCTAssertTrue([[intNullable numberValue] intValue] == 1, DBUEqualityTestFailed);
    XCTAssertTrue(intNullable.description != nil, DBUNotNilTestFailed);
    
    // set value to null
    System_NullableA1 *intNullable2 = [System_NullableA1 newNullableFromObject:nil withTypeArgumentName:@"int32_t"];
    [refObject setIntNullable:intNullable2];
    intNullable = [refObject intNullable];
    XCTAssertTrue(intNullable == nil, DBUNilTestFailed);
    
    // get float null
    System_NullableA1 *floatNullable = [refObject floatNullable];
    XCTAssertTrue(floatNullable == nil, DBUNilTestFailed);

    // float
    System_NullableA1 *floatNullable2 = [System_NullableA1 newNullableFromObject:@((float)5) withTypeArgumentName:@"float"];
    [refObject setFloatNullable:floatNullable2];
    floatNullable = [refObject floatNullable];
    XCTAssertTrue(floatNullable != nil, DBUNotNilTestFailed);
    XCTAssertTrue([[floatNullable numberValue] floatValue] == 5, DBUEqualityTestFailed);
    XCTAssertTrue(floatNullable.description != nil, DBUNotNilTestFailed);
    
    // enum
    // nullable enums must be created from an instance of the enum not the underlying type
    [System_NullableA1 objectWithManagedObject:[DULongEnum_ enumWithValue:Dubrovnik_UnitTests_LongEnum_val1]];
    
    //=========================================================
    // Generic reference object
    // Dubrovnik.UnitTests.GenericReferenceObject<T, U>"
    // This generic type is defined by the unit test assembly
    //=========================================================
    // T string
    // U string
    DBUGenericReferenceObjectA2 *refObjectA2 = [refObject stringStringGenericReferenceObject];
    
    // properties
    id gp1 = refObjectA2.genericPropertyWithTypeParameterT;
    XCTAssertTrue([gp1 isEqual:@"I am of type T == string"], DBUEqualityTestFailed);
    
    id gp2 = refObjectA2.genericPropertyWithTypeParameterU;
    XCTAssertTrue([gp2 isEqual:@"I am of type U == string"], DBUEqualityTestFailed);
    
    // methods
    System_String *ms1 = [@"I am of type T == string" managedString];
    System_String *ms2 = [@"I am of type U == string" managedString];
    id gm1 = [refObjectA2 genericMethodReturningParameterTypeT_withParameterT:ms1 parameterU:ms2];
    XCTAssertTrue([gm1 isEqual:@"I am of type T == string"], DBUEqualityTestFailed);

    id gm2 = [refObjectA2 genericMethodReturningParameterTypeU_withParameterT:ms1 parameterU:ms2];
    XCTAssertTrue([gm2 isEqual:@"I am of type U == string"], DBUEqualityTestFailed);
    
    // in this case the managed type signature is
    // public V GenericMethod<V>(T parameterT, U parameterU, V parameterV)
    // the T and U type parameters are supplied by the closed constructed type
    DBNumber *number = [DBNumber numberWithInt:101];
    id gm3 = [refObjectA2 genericMethod_withParameterT:ms1 parameterU:ms2 parameterV:number.managedObject typeParameter:number];
    XCTAssertTrue([gm3 isKindOfClass:[DBNumber class]] && [(DBNumber *)gm3 intValue] == 101, DBUEqualityTestFailed);
}

- (void)doTestArrayListRepresentation:(id)refObject class:(Class)testClass
{
#pragma unused(testClass)
    // string array list
    System_Collections_ArrayList *stringArrayList = [refObject stringArrayList];
    XCTAssertTrue([stringArrayList count] == 3, DBUCountTestFailed);
    
    // index using objectAtIndex:
    NSMutableString *ms = [NSMutableString new];
    for (int32_t i = 0; i < [stringArrayList count]; i++) {
        NSString * s = [stringArrayList objectAtIndex:i];
        [ms appendFormat:@"%@ ", s];
    }
    XCTAssertTrue([ms dbTestString:DBUTestString], DBUSubstringTestFailed);
    
    // index using managed indexer get_Item_withIndex:
    ms = [NSMutableString new];
    for (int32_t i = 0; i < [stringArrayList count]; i++) {
        NSString *s = (NSString *)[stringArrayList get_Item_withIndex:i];
        [ms appendFormat:@"%@ ", s];
    }
    XCTAssertTrue([ms dbTestString:DBUTestString], DBUSubstringTestFailed);
}

- (void)doTestEnumerations
{

    if (m_runningAutoGenCodeTest) {

        XCTAssertTrue(Dubrovnik_UnitTests_ByteEnum_val1 == [DUByteEnum_ val1], DBUEqualityTestFailed);
        XCTAssertTrue(Dubrovnik_UnitTests_ByteEnum_val2 == [DUByteEnum_ val2], DBUEqualityTestFailed);
        XCTAssertTrue(Dubrovnik_UnitTests_ByteEnum_val3 == [DUByteEnum_ val3], DBUEqualityTestFailed);
        XCTAssertTrue(Dubrovnik_UnitTests_ByteEnum_val4 == [DUByteEnum_ val4], DBUEqualityTestFailed);
        
        XCTAssertTrue(Dubrovnik_UnitTests_ShortEnum_val1 == [DUShortEnum_ val1], DBUEqualityTestFailed);
        XCTAssertTrue(Dubrovnik_UnitTests_ShortEnum_val2 == [DUShortEnum_ val2], DBUEqualityTestFailed);
        XCTAssertTrue(Dubrovnik_UnitTests_ShortEnum_val3 == [DUShortEnum_ val3], DBUEqualityTestFailed);
        XCTAssertTrue(Dubrovnik_UnitTests_ShortEnum_val4 == [DUShortEnum_ val4], DBUEqualityTestFailed);
        
        XCTAssertTrue(Dubrovnik_UnitTests_IntEnum_val1 == [DUIntEnum_ val1], DBUEqualityTestFailed);
        XCTAssertTrue(Dubrovnik_UnitTests_IntEnum_val2 == [DUIntEnum_ val2], DBUEqualityTestFailed);
        XCTAssertTrue(Dubrovnik_UnitTests_IntEnum_val3 == [DUIntEnum_ val3], DBUEqualityTestFailed);
        XCTAssertTrue(Dubrovnik_UnitTests_IntEnum_val4 == [DUIntEnum_ val4], DBUEqualityTestFailed);
        
        XCTAssertTrue(Dubrovnik_UnitTests_LongEnum_val1 == [DULongEnum_ val1], DBUEqualityTestFailed);
        XCTAssertTrue(Dubrovnik_UnitTests_LongEnum_val2 == [DULongEnum_ val2], DBUEqualityTestFailed);
        XCTAssertTrue(Dubrovnik_UnitTests_LongEnum_val3 == [DULongEnum_ val3], DBUEqualityTestFailed);
        XCTAssertTrue(Dubrovnik_UnitTests_LongEnum_val4 == [DULongEnum_ val4], DBUEqualityTestFailed);
    
        DUByteEnum_ *byteEnum = [DUByteEnum_ enumWithValue:Dubrovnik_UnitTests_ByteEnum_val1];
        XCTAssertTrue(byteEnum.db_int8Value == Dubrovnik_UnitTests_ByteEnum_val1, DBUEqualityTestFailed);
        
        DUShortEnum_ *shortEnum = [DUShortEnum_ enumWithValue:Dubrovnik_UnitTests_ShortEnum_val1];
        XCTAssertTrue(shortEnum.db_int16Value == Dubrovnik_UnitTests_ShortEnum_val1, DBUEqualityTestFailed);
        
        DUIntEnum_ *intEnum = [DUIntEnum_ enumWithValue:Dubrovnik_UnitTests_IntEnum_val1];
        XCTAssertTrue(intEnum.db_int32Value == Dubrovnik_UnitTests_IntEnum_val1, DBUEqualityTestFailed);
        
        DULongEnum_ *longEnum = [DULongEnum_ enumWithValue:Dubrovnik_UnitTests_LongEnum_val1];
        XCTAssertTrue(longEnum.db_int64Value == Dubrovnik_UnitTests_LongEnum_val1, DBUEqualityTestFailed);
        
        NSString *stringValue = [System_Enum getName_withEnumType:[DULongEnum_ db_getType] value:longEnum];
        XCTAssertTrue([stringValue isEqualToString:@"val1"], DBUEqualityTestFailed);
    }
}

- (void)doTestStructRepresentation:(id)refObject class:(Class)testClass
{
    
#pragma unused(testClass)

    //
    // Managed struct handling
    //
    id refStruct = [refObject referenceStructMethod_withS1:@"ReferenceStruct"];
    XCTAssertNotNil(refStruct, DBUObjectIsNil);
    
    NSString *refStructStringProperty = [refStruct stringProperty];
    XCTAssertTrue([refStructStringProperty dbTestString:DBUTestString], DBUSubstringTestFailed);
    
    NSString *refStructStringMethod = [refStruct stringMethod_withS1:@"ReferenceStruct"];
    XCTAssertTrue([refStructStringMethod dbTestString:DBUTestString], DBUSubstringTestFailed);
    
    // log the struct
    if (0) {
        [refStruct logMonoClassInfo];
    }
}

- (void)doTestObjectRepresentation:(id)refObject class:(Class)testClass
{

    #pragma unused(testClass)
    
    //
    // managed interface property
    //

    // check that interface property can be accessed via native object and by interface object
    int32_t impIntValue = [refObject impIntTestProperty];
    NSAssert(impIntValue == 30303, DBUEqualityTestFailed);
    
    // note that we used the generated interface here
    Dubrovnik_UnitTests_IReferenceObject1 *refObject1Imp = [Dubrovnik_UnitTests_IReferenceObject1 objectWithMonoObject:[refObject monoObject]];
    int32_t impIntValue2 = [refObject1Imp impIntTestProperty];
    NSAssert(impIntValue2 == impIntValue, DBUEqualityTestFailed);
    
    if (m_runningAutoGenCodeTest) {
        
        // +objectWithMonoObject: should return instance of receiver
        Dubrovnik_UnitTests_IReferenceObject1 *refObject1Imp3 = [Dubrovnik_UnitTests_IReferenceObject1 objectWithMonoObject:[refObject monoObject]];
        NSAssert([refObject1Imp3 isKindOfClass:[Dubrovnik_UnitTests_IReferenceObject1 class]], DBUClassEqualityTestFailed);
        int32_t impIntValue3 = [refObject1Imp3 impIntTestProperty];
        NSAssert(impIntValue3 == impIntValue, DBUEqualityTestFailed);
        
        // +bestObjectWithMonoObject: should return subclass
        Dubrovnik_UnitTests_IReferenceObject1 *refObject1Imp4 = [System_Object bestObjectWithMonoObject:[refObject monoObject]];
        NSAssert([refObject1Imp4 isKindOfClass:[DUReferenceObject_ class]], DBUClassEqualityTestFailed);
        NSAssert(refObject1Imp4 == refObject, DBUPointerEqualityTestFailed);
        int32_t impIntValue4 = [refObject1Imp4 impIntTestProperty];
        NSAssert(impIntValue4 == impIntValue, DBUEqualityTestFailed);
        
        /* TODO:
         
         +bestObjectWithMonoObject: will return the best object it can find.
         If no equivalent Obj-C class equivalent can be found for the managed class (which can occur, say, with EntityFrame LINQ queries that
         return IEnumerable`1<T>) then an Obj-C instance of the receiver is returned.
         We don't have a test for this behaviour at the moment as I am not sure at the moment how to implement it.
         Perhaps a dynamically created class that implements IEnumerable`1<T> would do the trick?
         http://stackoverflow.com/questions/3862226/dynamically-create-a-class-in-c-sharp
         We could provide the dynamic class via a string representation.
         
         */
    }
    
    // get managed interface object
    id minimRefObject = [refObject minimalReferenceObject];
    
    // query interface method
    NSString * minimalRefString = [minimRefObject stringMethod_withS1:@"1" n:2];
    XCTAssertTrue([minimalRefString dbTestString:DBUTestString], DBUSubstringTestFailed);
    
    // query explicit interface implementation properties.
    // we should be able to access the same property with three different return types via the
    // original object and two explicit interface references.
    
    // BOOL
    BOOL boolValue = [(DBUReferenceObject *)refObject exIntTestProperty];   // cast need to silence type warning
    NSAssert(boolValue == YES, DBUEqualityTestFailed);
    
    // int
    // note that this is slightly complicated by the fact that the code generator defaults to using +bestObjectWithMonoObject which prefers to
    // return a class rather than an interface; hence we explictly create interface based instances below.
    // see use of DB_INTERFACE macro below
    Dubrovnik_UnitTests_IReferenceObject1 *refObject1 = [Dubrovnik_UnitTests_IReferenceObject1 objectWithMonoObject:[refObject monoObject]];
    [refObject1 setExIntTestProperty:89467];
    int32_t intValue = [refObject1 exIntTestProperty];
    NSAssert(intValue == 89467, DBUEqualityTestFailed);
    
    if (m_runningAutoGenCodeTest) {
        // there ar emore convenient ways of generating interface instances
        Dubrovnik_UnitTests_IReferenceObject1 *refObject1a = DB_INTERFACE(Dubrovnik_UnitTests_IReferenceObject1, refObject);
        Dubrovnik_UnitTests_IReferenceObject1 *refObject1b = [Dubrovnik_UnitTests_IReferenceObject1 objectWithConformingManagedObject:refObject];
        
        // the interface instances should be cached so check for idnetical objects
        XCTAssertTrue(refObject1 == refObject1a && refObject1 == refObject1b, DBUEqualityTestFailed);
    }
    
    // float
    Dubrovnik_UnitTests_IReferenceObject2 *refObject2 = [Dubrovnik_UnitTests_IReferenceObject2 objectWithMonoObject:[refObject monoObject]];
    [refObject2 setExIntTestProperty:20202.f];
    float floatValue = [refObject2 exIntTestProperty];
    NSAssert(floatValue == 20202.f, DBUEqualityTestFailed);
}

- (void)doTestProperties:(id)refObject class:(Class)testClass
{
    //
    // class properties
    //
    NSString *classStringProperty = [testClass classStringProperty];
    XCTAssertTrue([classStringProperty isEqualToString:@"Dubrovnik.UnitTests static property"], DBUEqualityTestFailed);

    NSDate *classDateProperty = [testClass classDateProperty];
    NSDate *testDate = [NSDate dateWithString:@"2014-04-06 00:00:00 +0000"];
    XCTAssertTrue([classDateProperty compare:testDate] == NSOrderedSame, DBUEqualityTestFailed);

    //
    // string property
    //
    NSString *stringProperty = [refObject stringProperty];
    XCTAssertNotNil(stringProperty, DBUObjectIsNil);
    
    // setter
    stringProperty = [stringProperty stringByAppendingString:@" : modified"];
    [refObject setStringProperty:stringProperty];
    XCTAssertTrue([[refObject stringProperty] isEqualToString:stringProperty], DBUEqualityTestFailed);
    
    //
    // int32 property
    //
    int32_t int32 = [refObject int32Number];
    XCTAssertTrue(int32 != 0, DBUEqualityTestFailed);
    
    // setter
    int32 = 320;
    [refObject setInt32Number:int32];
    XCTAssertTrue([refObject int32Number] == int32, DBUEqualityTestFailed);
    
    //
    // int64 property
    //
    int64_t int64 = [refObject int64Number];
    XCTAssertTrue(int64 != 0, DBUEqualityTestFailed);
    
    // setter
    int64 = 640;
    [refObject setInt64Number:int64];
    XCTAssertTrue([refObject int64Number] == int64, DBUEqualityTestFailed);
    
    //
    // object property
    //
    id refObject2 = [[testClass alloc] init];
    XCTAssertNotNil(refObject2, DBUObjectNotCreated);
    
    NSString *refObject2StringProperty = @"This is general test 2";
    [refObject2 setStringProperty:refObject2StringProperty];
    [refObject setReferenceObjectRelative:refObject2];
    XCTAssertTrue([[[refObject referenceObjectRelative] stringProperty] isEqualToString:refObject2StringProperty], DBUEqualityTestFailed);
    
    //
    // date property
    //
    
    NSDate *dateNow = [refObject date];
    XCTAssertNotNil(dateNow, DBUObjectIsNil);
    XCTAssertTrue([[NSDate date] timeIntervalSinceDate:dateNow] < 60, DBULessThanTestFailed);    // Why 60? In case we we trigger a breakpoint, take a peek  and then continue.
    
    [refObject setDate:dateNow];
    
    // setter
    NSDate *dateFuture = [NSDate dateWithTimeIntervalSinceNow:60*60*24];
    [refObject setDate:dateFuture];
    NSDate *dateTomorrow = [refObject date];
    NSTimeInterval futureInterval = [dateFuture timeIntervalSinceReferenceDate];
    NSTimeInterval tomorrowInterval = [dateTomorrow timeIntervalSinceReferenceDate];
    NSTimeInterval interval = fabs(futureInterval - tomorrowInterval);
    XCTAssertTrue(interval < 0.1, DBULessThanTestFailed);
    
    if (_verbose) {
        NSLog(@"Now : %@", dateNow);
        NSLog(@"Future : %@", dateFuture);
        NSLog(@"Tomorrow : %@", dateTomorrow);
    }
    
    //
    // decimal number property
    //
    NSDecimalNumber *decimalNumber = [refObject decimalNumber];
    XCTAssertTrue(decimalNumber.doubleValue > 0.1, DBUGreaterThanTestFailed);
    
    // setter
    NSDecimalNumber *newDecimalNumber = [NSDecimalNumber decimalNumberWithString:@"500.5005"];
    [refObject setDecimalNumber:newDecimalNumber];
    XCTAssertTrue([[refObject decimalNumber] isEqualTo:newDecimalNumber], DBUEqualityTestFailed);
    
    if (_verbose) {
        NSLog(@"Decimal number : %@", decimalNumber);
        NSLog(@"New decimal number : %@", [refObject decimalNumber]);
    }

    //
    // enumeration properties
    //
    eDBUIntEnum intEnumeration = [refObject intEnumeration];
    XCTAssertTrue(intEnumeration == [DBUIntEnum val1], DBUEqualityTestFailed);
    
    int64_t longEnumeration = [refObject longEnumeration];
    XCTAssertTrue(longEnumeration == eDBULongEnum_Val1, DBUEqualityTestFailed);
    
    // setter
    [refObject setIntEnumeration:[DBUIntEnum val4]];
    XCTAssertTrue([refObject intEnumeration] == [DBUIntEnum val4], DBUEqualityTestFailed);
    
    // we can set it out of range too - so be careful!
    [refObject setIntEnumeration:[DBUIntEnum val4] * 10];
    XCTAssertTrue([refObject intEnumeration] == [DBUIntEnum val4] * 10, DBUEqualityTestFailed);
    
    [refObject setLongEnumeration:eDBULongEnum_Val4];
    XCTAssertTrue([refObject longEnumeration] == eDBULongEnum_Val4, DBUEqualityTestFailed);
    
    // Nullable enum properties
    @try {
        [refObject setIntEnumerationNullable:[System_NullableA1 newNullableFromInt32:1]];
    }
    @catch(NSException *e) {
        NSLog(@"Mono 5.12+ do not allow System.Nullable<System.Enum> to be created with an instance of the underlying type. Earlier Mono versions do.");
    }
    [refObject setIntEnumerationNullable:[System_NullableA1 objectWithManagedObject:[DUIntEnum_ enumWithValue:Dubrovnik_UnitTests_IntEnum_val1]]];
    [refObject setLongEnumerationNullable:[System_NullableA1 objectWithManagedObject:[DULongEnum_ enumWithValue:Dubrovnik_UnitTests_LongEnum_val1]]];
}

- (void)doTestReferenceClass:(Class)testClass iterations:(int)iterations
{
    if (iterations < 1) {
        XCTAssertTrue(NO, @"The iteration count must be greater than 1 to ensure that caches that get setup on first access subsequently get queried.");
    }
    
    NSDate *startTime = [NSDate date];
    int loopCounter = iterations;
    
    do {
        //===================================
        // constructors
        //===================================
        id refObject = [self doTestConstructorsWithclass:testClass];
        
        [self doTestGenericConstructors:testClass];

        //==================================
        //
        // boxing and unboxing
        // note that when passing boxed value types to a System_Object parameter
        // we need to use the wrapper provided by System_ValueType -objectArg in order to prevent auto unboxing of the value type.
        // TODO: refactor the method calling API to query the method signature so that auto unboxing of value types
        // only occurs when appropriate.
        //==================================
        // System.Bool
        System_Boolean *boxedBool = [System_Boolean objectWithBool:YES];
        XCTAssertTrue([System_Convert toBoolean_withValueObject:boxedBool.objectArg] == YES, DBUEqualityTestFailed);
        boxedBool = [System_Boolean objectWithBool:NO];
        XCTAssertTrue([System_Convert toBoolean_withValueObject:boxedBool.objectArg] == NO, DBUEqualityTestFailed);
        
        // System.Byte
        System_Byte *boxedByte = [System_Byte objectWithUInt8:233];
        XCTAssertTrue([System_Convert toByte_withValueObject:boxedByte.objectArg] == 233, DBUEqualityTestFailed);

        // System.SByte
        System_SByte *boxedSByte = [System_SByte objectWithInt8:-56];
        XCTAssertTrue([System_Convert toSByte_withValueObject:boxedSByte.objectArg] == -56, DBUEqualityTestFailed);

        // System.Char
        System_Char *boxedChar = [System_Char objectWithUInt16:12567];
        XCTAssertTrue([System_Convert toChar_withValueObject:boxedChar.objectArg] == 12567, DBUEqualityTestFailed);

        // System.Decimal
        NSDecimalNumber *decimalValue = [NSDecimalNumber decimalNumberWithString:@"17645"];
        System_Decimal *boxedDecimal = [System_Decimal objectWithDecimal:decimalValue];
        XCTAssertTrue([[System_Convert toDecimal_withValueObject:boxedDecimal.objectArg] isEqual:decimalValue], DBUEqualityTestFailed);

        // System.Double
        System_Double *boxedDouble = [System_Double objectWithDouble:13.2245];
        XCTAssertTrue([System_Convert toDouble_withValueObject:boxedDouble.objectArg] == 13.2245, DBUEqualityTestFailed);

        // System.Single
        System_Single *boxedSingle = [System_Single objectWithFloat:13567];
        float resultFloat = [System_Convert toSingle_withValueObject:boxedSingle.objectArg];
        XCTAssertTrue(resultFloat == 13567, DBUEqualityTestFailed);
        
        // System.Int32
        System_Int32 *boxedInt32 = [System_Int32 objectWithInt32:-11234];
        XCTAssertTrue([System_Convert toInt32_withValueObject:boxedInt32.objectArg] == -11234, DBUEqualityTestFailed);
        
        // System.UInt32
        System_UInt32 *boxedUInt32 = [System_UInt32 objectWithUInt32:11234];
        XCTAssertTrue([System_Convert toUInt32_withValueObject:boxedUInt32.objectArg] == 11234, DBUEqualityTestFailed);

        // System.Int64
        System_Int64 *boxedInt64 = [System_Int64 objectWithInt64:-112343748];
        XCTAssertTrue([System_Convert toInt64_withValueObject:boxedInt64.objectArg] == -112343748, DBUEqualityTestFailed);

        // System.UInt64
        System_UInt64 *boxedUInt64 = [System_UInt64 objectWithUInt64:112343778];
        XCTAssertTrue([System_Convert toUInt64_withValueObject:boxedUInt64.objectArg] == 112343778, DBUEqualityTestFailed);
        
        // System.Int16
        System_Int16 *boxedInt16 = [System_Int16 objectWithInt16:-7897];
        XCTAssertTrue([System_Convert toInt16_withValueObject:boxedInt16.objectArg] == -7897, DBUEqualityTestFailed);

        // System.UInt16
        System_UInt16 *boxedUInt16 = [System_UInt16 objectWithUInt16:7895];
        XCTAssertTrue([System_Convert toUInt16_withValueObject:boxedUInt16.objectArg] == 7895, DBUEqualityTestFailed);
        
        //===================================
        // events
        //===================================
        
        // the fact that the manually generated object does not have a class
        // name that matches the managed object class causes the event tests to fail.
        // hence we call them on the auto generated code only
        if (m_runningAutoGenCodeTest) {
            [self doTestEvents:refObject class:testClass];
        }
        
        //===================================
        // equality
        //===================================
        [self doTestForEquality:refObject class:testClass];

        //===================================
        // fields
        //===================================
        [self doTestFields:refObject class:testClass];

        //===================================
        // methods
        //===================================
        [self doTestMethods:refObject class:testClass];
        [self doTestExtensionMethods:refObject class:testClass];
        [self doTestArrayMethods:refObject class:testClass];
        [self doTestPointerMethods:refObject class:testClass];
        [self doTestRefMethods:refObject class:testClass];
        [self doTestGenericMethods:refObject class:testClass];

        //===================================
        // properties
        //===================================
        NSDate *propertyStartTime = [NSDate date];
        [self doTestProperties:refObject class:testClass];
        [self doTestArrayProperties:refObject class:testClass];
        [self doTestGenericProperties:refObject class:testClass];
        [self doTestPointerProperties:refObject class:testClass];
        [self doTestPropertyPersistence:refObject class:testClass];
        [self doTestNotifyingProperties:refObject class:testClass];
        NSTimeInterval invokeInterval = -[propertyStartTime timeIntervalSinceNow];
        NSLog(@"%@ : property tests (%u) Time: %f", self.runModeName, 1, invokeInterval);
        
        //===================================
        // representations
        //===================================
        [self doTestStructRepresentation:refObject class:testClass];
        [self doTestObjectRepresentation:refObject class:testClass];
        [self doTestArrayListRepresentation:refObject class:testClass];
        [self doTestEnumerations];
        
        //===================================
        // Delegates
        //===================================
        if (m_runningAutoGenCodeTest) {
            [self doTestDelegates:refObject class:testClass];
        }
        
        if (!m_runningAutoGenCodeTest) {
            [self doTestThunks:refObject class:testClass];
        }
    } while (--loopCounter);
    
    NSTimeInterval invokeInterval = -[startTime timeIntervalSinceNow];
    NSLog(@"%@ : doTestReferenceClass(%u) Time: %f", self.runModeName, iterations, invokeInterval);
    
    // some simple timimgs used to highlight any disparity between legacy and modern method cache implementations
    startTime = [NSDate date];
    iterations = 10000000;
    char *properties[] = {"StringList", "BoolArray", "Date", "DecimalNumber"};
    NSUInteger max = sizeof(properties)/sizeof(char *);
    MonoClass *monoClass = [testClass monoClass];
    for (int i; i < iterations; i++) {
        for (NSUInteger j = 0; j < max; j++) {
            MonoMethod *method = GetPropertyGetMethod(monoClass, properties[j]);
            (void)method;
        }
    }
    invokeInterval = -[startTime timeIntervalSinceNow];
    NSLog(@"%@ : GetPropertyGetMethod(%u) Time: %f", self.runModeName, iterations, invokeInterval);
}

- (NSString *)runModeName
{
    return m_runningAutoGenCodeTest ? @"Generated code" : @"Manual code";
}


- (void)doTestEvents:(DUReferenceObject_ *)refObject class:(Class)testClass
{
    if (![refObject isKindOfClass:DUReferenceObject_.class]) {
        XCTAssertTrue(NO, @"Invalid reference object");
    }
    
    //
    // define blocks to be called when event delegate invoked
    //
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
    System_EventHandler *eh1 = [refObject unitTestEvent1_addEventHandlerWithBlock:^(System_Object *sender, System_EventArgs *e) {
        self.event1Fired++;
    }];
    System_EventHandler *eh2 = [refObject unitTestEvent2_addEventHandlerWithBlock:^(System_Object *sender, System_EventArgs *e) {
        self.event2Fired++;
    }];
    System_EventHandlerA1 *eh3 = [refObject unitTestEvent3_addEventHandlerWithBlock:^(System_Object *sender, Dubrovnik_UnitTests_ReferenceEventArgs *e) {
        XCTAssertTrue([e isKindOfClass:Dubrovnik_UnitTests_ReferenceEventArgs.class], DBUEqualityTestFailed);
        self.event1Fired++;
        self.event2Fired++;
    }];
#pragma clang diagnostic pop
    
    self.event1Fired = 0;
    self.event2Fired = 0;
    
    [refObject raiseUnitTestEvent1];
    XCTAssertTrue(self.event1Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 0, DBUEqualityTestFailed);
    
    [refObject raiseUnitTestEvent2];
    XCTAssertTrue(self.event1Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 1, DBUEqualityTestFailed);
    
    [refObject raiseUnitTestEvent3];
    XCTAssertTrue(self.event1Fired == 2, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 2, DBUEqualityTestFailed);
    
    //
    // define additional handlers for the same events
    //
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
    System_EventHandler *eh1a = [refObject unitTestEvent1_addEventHandlerWithBlock:^(System_Object *sender, System_EventArgs *e) {
        self.event1Fired += 2;
    }];
    System_EventHandler *eh2a = [refObject unitTestEvent2_addEventHandlerWithBlock:^(System_Object *sender, System_EventArgs *e) {
        self.event2Fired += 3;
    }];
    System_EventHandlerA1 *eh3a = [refObject unitTestEvent3_addEventHandlerWithBlock:^(System_Object *sender, Dubrovnik_UnitTests_ReferenceEventArgs *e) {
        XCTAssertTrue([e isKindOfClass:Dubrovnik_UnitTests_ReferenceEventArgs.class], DBUEqualityTestFailed);
        self.event1Fired += 4;
        self.event2Fired += 4;
    }];
#pragma clang diagnostic pop
    
    self.event1Fired = 0;
    self.event2Fired = 0;
    [refObject raiseUnitTestEvent1];
    XCTAssertTrue(self.event1Fired == 3, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 0, DBUEqualityTestFailed);
    
    [refObject raiseUnitTestEvent2];
    XCTAssertTrue(self.event1Fired == 3, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 4, DBUEqualityTestFailed);
    
    [refObject raiseUnitTestEvent3];
    XCTAssertTrue(self.event1Fired == 8, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 9, DBUEqualityTestFailed);
    
    //
    // now remove the additional handlers
    //
    [refObject db_removeEventHandler:eh1a];
    [refObject db_removeEventHandler:eh2a];
    [refObject db_removeEventHandler:eh3a];
    
    self.event1Fired = 0;
    self.event2Fired = 0;
    
    [refObject raiseUnitTestEvent1];
    XCTAssertTrue(self.event1Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 0, DBUEqualityTestFailed);
    
    [refObject raiseUnitTestEvent2];
    XCTAssertTrue(self.event1Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 1, DBUEqualityTestFailed);
    
    [refObject raiseUnitTestEvent3];
    XCTAssertTrue(self.event1Fired == 2, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 2, DBUEqualityTestFailed);
    
    //
    // now remove the original handlers
    //
    [refObject db_removeEventHandler:eh1];
    [refObject db_removeEventHandler:eh2];
    [refObject db_removeEventHandler:eh3];
    
    self.event1Fired = 0;
    self.event2Fired = 0;
    
    [refObject raiseUnitTestEvent1];
    XCTAssertTrue(self.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 0, DBUEqualityTestFailed);
    
    [refObject raiseUnitTestEvent2];
    XCTAssertTrue(self.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 0, DBUEqualityTestFailed);
    
    [refObject raiseUnitTestEvent3];
    XCTAssertTrue(self.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 0, DBUEqualityTestFailed);
    
    // test the legacy event API
    [self doTestLegacyEvents:refObject class:testClass];
}


/**
 Tests the legacy managed event API support.
 This API works fine but requires a lot of glue code including defining
 a managed static internal call method on a Dubrovnik.ClientApplication.EventHelper partial class.
 Note there is no code gen support for this API.
 The newer event API is much easier to use and is supported by the code generator.

 @param refObject Reference object
 @param testClass testClass Test class
 */
- (void)doTestLegacyEvents:(id)refObject class:(Class)testClass
{
#pragma unused(testClass)
    
    NSPointerArray * targets = nil;
    
    //=============================================
    // managed event API
    //
    // this API allows managed events to be fully
    // configured from unmanaged code.
    //=============================================
    
    // register unmanaged handlers for the managed events.
    // this associates a static managed event handler function with a static unmanaged handler function
    static BOOL m_eventHandlersRegistered = NO;
    if (!m_eventHandlersRegistered) {
        [DBManagedEvent registerManagedEventHandler:@"DubrovnikEventHandlerICall1" unmanagedHandler:&DubrovnikEventHandlerICall1];
        [DBManagedEvent registerManagedEventHandler:@"DubrovnikEventHandlerICall2" unmanagedHandler:&DubrovnikEventHandlerICall2];
        
        m_eventHandlersRegistered = YES;
    }
    
    
    //
    // add managed event handlers
    // this associates a managed event with a particular static managed event handler as registered above.
    // when the event fires it calls the managed function which is implemented by the unmanaged handler function.
    // the DBManagedEvent event dispatcher then dispatches a selector back to self et voila.
    //
    [self addManagedEventHandlerForObject:refObject eventName:@"UnitTestEvent1" handlerMethodName:@"DubrovnikEventHandlerICall1"];
    [self addManagedEventHandlerForObject:refObject eventName:@"UnitTestEvent2" handlerMethodName:@"DubrovnikEventHandlerICall2"];
    
    // check that targets have been set
    targets = [DBManagedEvent eventTargetsForSender:refObject eventName:@"UnitTestEvent1"];
    XCTAssertNotNil(targets, DBUNotNilTestFailed);
    XCTAssertTrue([targets db_indexForObjectPointer:self] != NSUIntegerMax, DBUEqualityTestFailed);
    
    targets = [DBManagedEvent eventTargetsForSender:refObject eventName:@"UnitTestEvent2"];
    XCTAssertNotNil(targets, DBUNotNilTestFailed);
    XCTAssertTrue([targets db_indexForObjectPointer:self] != NSUIntegerMax, DBUEqualityTestFailed);
    
    //
    // define another object of the same class to check that we can have multiple event subscribers
    // with the same class
    //
    Dubrovnik_Unit_Tests * testObject = [[self class] new];
    [testObject addManagedEventHandlerForObject:refObject eventName:@"UnitTestEvent1" handlerMethodName:@"DubrovnikEventHandlerICall1"];
    [testObject addManagedEventHandlerForObject:refObject eventName:@"UnitTestEvent2" handlerMethodName:@"DubrovnikEventHandlerICall2"];
    
    // check that targets have been set
    targets = [DBManagedEvent eventTargetsForSender:refObject eventName:@"UnitTestEvent1"];
    XCTAssertNotNil(targets, DBUNotNilTestFailed);
    XCTAssertTrue([targets db_indexForObjectPointer:testObject] != NSUIntegerMax, DBUEqualityTestFailed);
    
    targets = [DBManagedEvent eventTargetsForSender:refObject eventName:@"UnitTestEvent2"];
    XCTAssertNotNil(targets, DBUNotNilTestFailed);
    XCTAssertTrue([targets db_indexForObjectPointer:testObject] != NSUIntegerMax, DBUEqualityTestFailed);
    
    //
    // define an event target of another class
    //
    EventTarget *eventTarget = [EventTarget new];
    [eventTarget addManagedEventHandlerForObject:refObject eventName:@"UnitTestEvent1" handlerMethodName:@"DubrovnikEventHandlerICall1"];
    [eventTarget addManagedEventHandlerForObject:refObject eventName:@"UnitTestEvent2" handlerMethodName:@"DubrovnikEventHandlerICall2"];
    
    // check that targets have been set
    targets = [DBManagedEvent eventTargetsForSender:refObject eventName:@"UnitTestEvent1"];
    XCTAssertNotNil(targets, DBUNotNilTestFailed);
    XCTAssertTrue([targets db_indexForObjectPointer:eventTarget] != NSUIntegerMax, DBUEqualityTestFailed);
    
    targets = [DBManagedEvent eventTargetsForSender:refObject eventName:@"UnitTestEvent2"];
    XCTAssertNotNil(targets, DBUNotNilTestFailed);
    XCTAssertTrue([targets db_indexForObjectPointer:eventTarget] != NSUIntegerMax, DBUEqualityTestFailed);
    
    //
    // define another event source of this class
    //
    id refObject1 = [testClass new];
    [refObject1 setStringProperty:[[NSDate date] description]];
    EventTarget *eventTarget1 = [EventTarget new];
    [eventTarget1 addManagedEventHandlerForObject:refObject1 eventName:@"UnitTestEvent1" handlerMethodName:@"DubrovnikEventHandlerICall1"];
    [eventTarget1 addManagedEventHandlerForObject:refObject1 eventName:@"UnitTestEvent2" handlerMethodName:@"DubrovnikEventHandlerICall2"];
    
    // check that targets have been set
    targets = [DBManagedEvent eventTargetsForSender:refObject1 eventName:@"UnitTestEvent1"];
    XCTAssertNotNil(targets, DBUNotNilTestFailed);
    XCTAssertTrue([targets db_indexForObjectPointer:eventTarget1] != NSUIntegerMax, DBUEqualityTestFailed);
    
    targets = [DBManagedEvent eventTargetsForSender:refObject1 eventName:@"UnitTestEvent2"];
    XCTAssertNotNil(targets, DBUNotNilTestFailed);
    XCTAssertTrue([targets db_indexForObjectPointer:eventTarget1] != NSUIntegerMax, DBUEqualityTestFailed);
    
    // raise events
    RESET_EVENT_VARS(0);
    
    [refObject raiseUnitTestEvent1];
    [refObject1 raiseUnitTestEvent1];
    XCTAssertTrue(self.event1Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event1Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event2Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event1Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event2Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget1.event1Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget1.event2Fired == 0, DBUEqualityTestFailed);
    
    RESET_EVENT_VARS(0);
    
    [refObject raiseUnitTestEvent2];
    [refObject1 raiseUnitTestEvent2];
    XCTAssertTrue(self.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event2Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event2Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget1.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget1.event2Fired == 1, DBUEqualityTestFailed);
    
    // remove handler 1 for self
    [self removeManagedEventHandlerForObject:refObject eventName:@"UnitTestEvent1" handlerMethodName:@"DubrovnikEventHandlerICall1"];
    RESET_EVENT_VARS(0);
    
    [refObject raiseUnitTestEvent1];
    [refObject raiseUnitTestEvent2];
    XCTAssertTrue(self.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event1Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event2Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event1Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event2Fired == 1, DBUEqualityTestFailed);
    
    // remove handler 1 for testObject
    [testObject removeManagedEventHandlerForObject:refObject eventName:@"UnitTestEvent1" handlerMethodName:@"DubrovnikEventHandlerICall1"];
    RESET_EVENT_VARS(0);
    
    [refObject raiseUnitTestEvent1];
    [refObject raiseUnitTestEvent2];
    XCTAssertTrue(self.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event2Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event1Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event2Fired == 1, DBUEqualityTestFailed);
    
    // remove handler 2 for self
    [self removeManagedEventHandlerForObject:refObject eventName:@"UnitTestEvent2" handlerMethodName:@"DubrovnikEventHandlerICall2"];
    RESET_EVENT_VARS(0);
    
    [refObject raiseUnitTestEvent1];
    [refObject raiseUnitTestEvent2];
    XCTAssertTrue(self.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event2Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event1Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event2Fired == 1, DBUEqualityTestFailed);
    
    // remove handler 2 for testObject
    [testObject removeManagedEventHandlerForObject:refObject eventName:@"UnitTestEvent2" handlerMethodName:@"DubrovnikEventHandlerICall2"];
    RESET_EVENT_VARS(0);
    
    [refObject raiseUnitTestEvent1];
    [refObject raiseUnitTestEvent2];
    XCTAssertTrue(self.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event2Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event1Fired == 1, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event2Fired == 1, DBUEqualityTestFailed);
    
    // remove handler 1 for eventTarget
    [eventTarget removeManagedEventHandlerForObject:refObject eventName:@"UnitTestEvent1" handlerMethodName:@"DubrovnikEventHandlerICall1"];
    RESET_EVENT_VARS(0);
    
    [refObject raiseUnitTestEvent1];
    [refObject raiseUnitTestEvent2];
    XCTAssertTrue(self.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event2Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event2Fired == 1, DBUEqualityTestFailed);
    
    // remove handler 2 for eventTarget
    [eventTarget removeManagedEventHandlerForObject:refObject eventName:@"UnitTestEvent2" handlerMethodName:@"DubrovnikEventHandlerICall2"];
    RESET_EVENT_VARS(0);
    
    [refObject raiseUnitTestEvent1];
    [refObject raiseUnitTestEvent2];
    XCTAssertTrue(self.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(self.event2Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(testObject.event2Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event1Fired == 0, DBUEqualityTestFailed);
    XCTAssertTrue(eventTarget.event2Fired == 0, DBUEqualityTestFailed);
    
    // check that targets have been set to zero
    targets = [DBManagedEvent eventTargetsForSender:refObject eventName:@"UnitTestEvent1"];
    XCTAssertNotNil(targets, DBUNotNilTestFailed);
    XCTAssertTrue(targets.count == 0, DBUEqualityTestFailed);
    
    [DBManagedEvent eventTargetsForSender:refObject eventName:@"UnitTestEvent2"];
    XCTAssertNotNil(targets, DBUNotNilTestFailed);
    XCTAssertTrue(targets.count == 0, DBUEqualityTestFailed);
}

- (void)doTestDelegates:(id)refObject class:(Class)testClass
{
    #pragma unused(testClass)
    
    // we define a delegate context block to be invoked when delegate called
    DBUniversalDelegateBlock delegateBlock = nil;
    
    // create and invoke universal delegates
    
    // simple
    delegateBlock = ^System_Object *(NSArray * parameters) {
        NSAssert(parameters.count == 0, @"invalid parameters");
        return NULL;
    };
    DUReferenceObject_SimpleDelegate_ *simpleDelegate = [DUReferenceObject_SimpleDelegate_ universalDelegateWithBlock:delegateBlock];
    delegateBlock = nil;
    [simpleDelegate invoke]; // direct invoke
    [refObject invokeSimpleDelegate_withDelg:simpleDelegate];
    

    // action
    delegateBlock = ^System_Object *(NSArray * parameters) {
        NSAssert(parameters.count == 1 && [parameters[0] isEqualToString:@"Bingo"], @"invalid parameters");
        return NULL;
    };
    DUReferenceObject_ActionDelegate_ *actionDelegate = [DUReferenceObject_ActionDelegate_ universalDelegateWithBlock:delegateBlock];
    //delegateBlock = nil;
    [actionDelegate invoke_withMessage:@"Bingo"]; // direct invoke
    [refObject invokeActionDelegate_withActionDUReferenceObject__ActionDelegate:actionDelegate];
    
    // Generic System.Action<T>
    // in this case we need to construct the type of our delegate
    System_Type *constructedType = [System_ActionA1 db_constructTypeWithParameters:@[[System_String class]]];
    System_ActionA1 *actionDelegateA1 = [System_ActionA1 universalDelegateWithConstructedType:constructedType block:delegateBlock];
    [actionDelegateA1 invoke_withObj:[@"Bingo" managedString]];
    [refObject invokeActionDelegate_withActionSActionA1string:actionDelegateA1];
      
    // Generic System.Action<T1,T2>
    // in this case we need to construct the type of our delegate
    delegateBlock = ^System_Object *(NSArray * parameters) {
        NSAssert(parameters.count == 2 && [parameters[0] isEqualToString:@"Bingo"] && [parameters[1] isEqualToString:@"More"], @"invalid parameters");
        return NULL;
    };
    constructedType = [System_ActionA2 db_constructTypeWithParameters:@[[System_String class], [System_Object class]]];
    System_ActionA2 *actionDelegateA2 = [System_ActionA2 universalDelegateWithConstructedType:constructedType block:delegateBlock];
    [actionDelegateA2 invoke_withArg1:@"Bingo".managedString arg2:@"More".managedString];
    
    // unit test call passes integer
    delegateBlock = ^System_Object *(NSArray * parameters) {
        NSAssert(parameters.count == 2 && [parameters[0] isEqualToString:@"Bingo"] && ((DBNumber *)parameters[1]).integerValue == 101 , @"invalid parameters");
        return NULL;
    };
    actionDelegateA2 = [System_ActionA2 universalDelegateWithConstructedType:constructedType block:delegateBlock];
    [refObject  invokeActionDelegate_withActionSActionA2string_object:actionDelegateA2];
    
    // func 1
    delegateBlock = ^System_Object *(NSArray * parameters) {
        NSAssert(parameters.count == 1 && [parameters[0] isEqualToString:@"Bullseye"], @"invalid parameters");
        return [DBNumber numberWithInt:10245].managedObject;
    };
    DUReferenceObject_FunctionDelegate1_ *functionDelegate1 = [DUReferenceObject_FunctionDelegate1_ universalDelegateWithBlock:delegateBlock];
    delegateBlock = nil;
    int32_t intResult1 = [functionDelegate1 invoke_withObject:[@"Bullseye" managedString]];
    XCTAssertTrue(intResult1 == 10245, DBUEqualityTestFailed); // direct invoke
    [refObject invokeFunctionDelegate1_withFunc:functionDelegate1];
    
    // func 2
    delegateBlock = ^System_Object *(NSArray * parameters) {
        NSAssert(parameters.count == 2 && [parameters[0] isEqual:@(101)] && [parameters[1] isEqualToString:@"Birdshot"], @"invalid parameters");
        return [DBNumber numberWithInt:17654].managedObject;
    };
    DUReferenceObject_FunctionDelegate2_ *functionDelegate2 = [DUReferenceObject_FunctionDelegate2_ universalDelegateWithBlock:delegateBlock];
    delegateBlock = nil;
    int32_t intResult2 = [functionDelegate2 invoke_withValue:101 message:@"Birdshot"]; // direct invoke
    XCTAssertTrue(intResult2 == 17654, DBUEqualityTestFailed);
    [refObject invokeFunctionDelegate2_withFunc:functionDelegate2];
    
    // System_FuncA1<TResult>
    // in this case we need to construct the type of our delegate
     delegateBlock = ^System_Object *(NSArray * parameters) {
         NSAssert(parameters.count == 0, @"invalid parameters");
         return DBNumInt(182767).managedObject;
     };
    constructedType = [System_FuncA1 db_constructTypeWithParameters:@[[System_Int32 class]]];
    System_FuncA1 *funcDelegateA1 = [System_FuncA1 universalDelegateWithConstructedType:constructedType block:delegateBlock];
    int32_t intResultA1 = [refObject invokeFunctionA1_withFunc:funcDelegateA1];
    XCTAssertTrue(intResultA1 == 182767, DBUEqualityTestFailed);
    
    // System_FuncA2<TResult>
    // in this case we need to construct the type of our delegate
    delegateBlock = ^System_Object *(NSArray * parameters) {
        NSAssert(parameters.count == 1 && ((DBNumber *)parameters[0]).integerValue == 104, @"invalid parameters");
        return @"Klepto".managedObject;
    };
    constructedType = [System_FuncA2 db_constructTypeWithParameters:@[[System_Int32 class], [System_String class]]];
    System_FuncA2 *funcDelegateA2 = [System_FuncA2 universalDelegateWithConstructedType:constructedType block:delegateBlock];
    NSString *resultFuncA2 = [refObject invokeFunctionA2_withFunc:funcDelegateA2];
    XCTAssertTrue([resultFuncA2 isEqualToString:@"Klepto"], DBUEqualityTestFailed);
    
    // System_FuncA3<TResult>
    // in this case we merely pass the delegate types into the convenience method
    delegateBlock = ^System_Object *(NSArray * parameters) {
        NSAssert(parameters.count == 2 && ((DBNumber *)parameters[0]).integerValue == 104 && ((DBNumber *)parameters[1]).doubleValue == 202.2, @"invalid parameters");
        return @"Battery".managedObject;
    };
    NSArray<id> *delegateTypes = @[[System_Int32 class], [System_Double class], [System_String class]];
    System_FuncA3 *funcDelegateA3 = [System_FuncA3 universalDelegate:delegateTypes block:delegateBlock];
    NSString *resultFuncA3 = [refObject invokeFunctionA3_withFunc:funcDelegateA3];
    XCTAssertTrue([resultFuncA3 isEqualToString:@"Battery"], DBUEqualityTestFailed);
}

#pragma mark -
#pragma mark Thunk evaluation

- (void)doTestThunks:(id)refObject class:(Class)testClass
{
    #pragma unused(testClass)
    
    // this works for the manually generated bindings because they
    // use method invoke as opposed to thunks
    NSLog(@"============================================");
    NSLog(@"Method invoke re thunk performace comparison");
    NSLog(@"============================================");
    NSString *stringValue = [refObject stringProperty];
    
    // raw thunk versus invoke timing test
    [refObject stringPropertyAccessTimingTest];
    
    // more representative usage case scenarios
    
    // getter
    // method invoke
    int count = 1000000;
    NSDate *startTime = [NSDate date];
    for (int i = 0; i < count; i++) {
        [refObject stringProperty];
    }
    NSTimeInterval invokeInterval = -[startTime timeIntervalSinceNow];
    NSLog(@"Scenario Invoke Get Time: %f", invokeInterval);
    
    // thunk
    startTime = [NSDate date];
    for (int i = 0; i < count; i++) {
        [refObject stringPropertyViaThunk];
    }
    NSTimeInterval thunkInterval = -[startTime timeIntervalSinceNow];
    NSLog(@"Scenario Thunk Get Time: %f", thunkInterval);
    NSLog(@"Scenario Get Invoke/Thunk: %f", invokeInterval / thunkInterval);
    
    // setter
    // method invoke
    startTime = [NSDate date];
    for (int i = 0; i < count; i++) {
        [refObject setStringProperty:stringValue];
    }
    invokeInterval = -[startTime timeIntervalSinceNow];
    NSLog(@"Scenario Invoke Set Time: %f", invokeInterval);
    
    // thunk invoke
    startTime = [NSDate date];
    for (int i = 0; i < count; i++) {
        [refObject setStringPropertyViaThunk:stringValue];
    }
    thunkInterval = -[startTime timeIntervalSinceNow];
    NSLog(@"Scenario Thunk Set Time: %f", thunkInterval);
    NSLog(@"Scenario Set Invoke/Thunk: %f", invokeInterval / thunkInterval);

    // method
    NSString *stringS1 = @"just what";
    MonoString *monoString = mono_string_new(mono_domain_get(), "2");
    DBManagedObject *stringObj = [DBManagedObject objectWithMonoObject:(MonoObject *)monoString];

    // method invoke
    startTime = [NSDate date];
    for (int i = 0; i < count; i++) {
        [refObject stringMethod_withS1String:stringS1 s2Object:stringObj];
    }
    invokeInterval = -[startTime timeIntervalSinceNow];
    NSLog(@"Scenario Invoke Method Time: %f", invokeInterval);
    
    // method
    // thunk invoke
    startTime = [NSDate date];
    for (int i = 0; i < count; i++) {
        [refObject stringMethodViaThunk_withS1String:stringS1 s2Object:stringObj];
    }
    thunkInterval = -[startTime timeIntervalSinceNow];
    NSLog(@"Scenario Thunk Method Time: %f", thunkInterval);
    NSLog(@"Scenario Method Invoke/Thunk: %f", invokeInterval / thunkInterval);
}

#pragma mark -
#pragma mark Event handler support

// managed event callbacks that route events back to registered event target
static void DubrovnikEventHandlerICall1(MonoObject* monoSender, MonoObject* monoEventArgs)
{
    
    [DBManagedEvent dispatchEventFromMonoSender:monoSender
                                      eventArgs:monoEventArgs
                                      eventName:@"UnitTestEvent1"
                             targetSelectorName:@"event1ReceivedFromSender:item:"];
}

- (void)event1ReceivedFromSender:(DBManagedObject *)sender item:(System_EventArgs *)item
{
#pragma unused(sender, item)
    self.event1Fired++;
}

static void DubrovnikEventHandlerICall2(MonoObject* monoSender, MonoObject* monoEventArgs)
{
    [DBManagedEvent dispatchEventFromMonoSender:monoSender
                                      eventArgs:monoEventArgs
                                      eventName:@"UnitTestEvent2"
                             targetSelectorName:@"event2ReceivedFromSender:item:"];
}

- (void)event2ReceivedFromSender:(id)sender item:(System_EventArgs *)item
{
#pragma unused(sender, item)
    self.event2Fired++;
}

#pragma mark -
#pragma mark DBManagedEnvironmentDelegate methods

- (NSString *)managedEnvironment:(DBManagedEnvironment *)monoEnv pathToAssemblyName:(const char *)name
{
#pragma unused(monoEnv)
#pragma unused(name)
    NSString *path = nil;

    // Provide a path to the named assembly dll.
    // If nil is returned then the environment will attempt to load the assembly from the default mono version on the assembly root path.
    
    return path;
}

@end

@implementation EventTarget

- (void)event1ReceivedFromSender:(DBManagedObject *)sender item:(System_EventArgs *)item
{
#pragma unused(sender, item)
    
    self.event1Fired++;
}

- (void)event2ReceivedFromSender:(DBManagedObject *)sender item:(System_EventArgs *)item
{
#pragma unused(sender, item)
    self.event2Fired++;
}

@end
